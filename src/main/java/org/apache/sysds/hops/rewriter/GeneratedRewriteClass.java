package org.apache.sysds.hops.rewriter;

import java.util.ArrayList;
import java.util.function.Function;

import org.apache.sysds.hops.Hop;
import org.apache.sysds.hops.LiteralOp;
import org.apache.sysds.hops.UnaryOp;
import org.apache.sysds.hops.BinaryOp;
import org.apache.sysds.hops.ReorgOp;
import org.apache.sysds.hops.AggUnaryOp;
import org.apache.sysds.hops.AggBinaryOp;
import org.apache.sysds.hops.DataGenOp;
import org.apache.sysds.hops.TernaryOp;
import org.apache.sysds.common.Types;
import org.apache.sysds.hops.rewrite.HopRewriteUtils;

public class GeneratedRewriteClass implements Function {

	@Override
	public Object apply( Object _hi ) {
		if ( _hi == null )
			return null;

		Hop hi = (Hop) _hi;

		if ( hi.getDataType() == Types.DataType.SCALAR ) {
			if ( hi instanceof BinaryOp ) {
				if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.MULT ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.SCALAR ) {
							if ( hi_0 instanceof BinaryOp ) {
								hi = _applyRewrite77(hi); // *(/(1.0,b),a) => /(a,b)
								hi = _applyRewrite83(hi); // *(-(a,0.0),b) => *(a,b)
							} else {
								if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
									if ( hi_1 instanceof BinaryOp ) {
										hi = _applyRewrite78(hi); // *(a,/(1.0,b)) => /(a,b)
										hi = _applyRewrite84(hi); // *(a,-(b,0.0)) => *(a,b)
									} else {
										hi = _applyRewrite0(hi); // *(1.0,a) => a
										hi = _applyRewrite1(hi); // *(a,1.0) => a
										hi = _applyRewrite7(hi); // *(0.0,a) => 0.0
										hi = _applyRewrite8(hi); // *(a,0.0) => 0.0
									}
								}
							}
						}
					}
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.DIV ) {
					hi = _applyRewrite2(hi); // /(a,1.0) => a
					hi = _applyRewrite9(hi); // /(0.0,a) => 0.0
					hi = _applyRewrite85(hi); // /(-(a,0.0),b) => /(a,b)
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.PLUS ) {
					hi = _applyRewrite3(hi); // +(0.0,a) => a
					hi = _applyRewrite4(hi); // +(a,0.0) => a
					hi = _applyRewrite81(hi); // +(-(0.0,b),a) => -(a,b)
					hi = _applyRewrite82(hi); // +(a,-(0.0,b)) => -(a,b)
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.MINUS ) {
					hi = _applyRewrite79(hi); // -(0.0,-(b,a)) => -(a,b)
					hi = _applyRewrite80(hi); // -(a,-(b,0.0)) => -(a,b)
				}
			} else if ( hi instanceof AggUnaryOp ) {
				if ( (( AggUnaryOp ) hi ).getOp() == Types.AggOp.SUM ) {
					if ( hi.getInput().size() == 1 ) {
						Hop hi_0 = hi.getInput(0);
						if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite147(hi); // trace(!=(b,t(A))) => trace(!=(A,b))
											hi = _applyRewrite168(hi); // trace(!=(sum(A),A)) => trace(!=(A,trace(A)))
											hi = _applyRewrite180(hi); // sum(!=(b,t(A))) => sum(!=(A,b))
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_0_0 instanceof ReorgOp ) {
												hi = _applyRewrite136(hi); // trace(!=(t(B),A)) => trace(!=(A,B))
												hi = _applyRewrite146(hi); // trace(!=(t(A),b)) => trace(!=(A,b))
												hi = _applyRewrite179(hi); // sum(!=(t(A),b)) => sum(!=(A,b))
											} else {
												hi = _applyRewrite137(hi); // trace(!=(A,t(B))) => trace(!=(A,B))
												hi = _applyRewrite169(hi); // trace(!=(A,sum(A))) => trace(!=(A,trace(A)))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite16(hi); // trace(*(a,B)) => *(a,trace(B))
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_0_0 instanceof BinaryOp ) {
												hi = _applyRewrite120(hi); // trace(*($1:/(a,C),B)) => *(a,trace(/(B,C)))
												hi = _applyRewrite150(hi); // sum(*($1:/(a,C),B)) => *(a,sum(/(B,C)))
											} else if ( hi_0_0 instanceof ReorgOp ) {
												hi = _applyRewrite183(hi); // trace(*($1:t(B),A)) => trace(*(A,B))
											} else {
												hi = _applyRewrite17(hi); // trace(*(B,a)) => *(a,trace(B))
												hi = _applyRewrite121(hi); // trace(*(B,$1:/(a,C))) => *(a,trace(/(B,C)))
												hi = _applyRewrite151(hi); // sum(*(B,$1:/(a,C))) => *(a,sum(/(B,C)))
												hi = _applyRewrite184(hi); // trace(*(B,$1:t(A))) => trace(*(A,B))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											if ( hi_0_1.getDataType() == Types.DataType.MATRIX ) {
												if ( hi_0_1 instanceof ReorgOp ) {
													hi = _applyRewrite139(hi); // trace(-(a,$1:t(B))) => trace(-(a,B))
													hi = _applyRewrite178(hi); // sum(-(a,$1:t(B))) => sum(-(a,B))
												} else if ( hi_0_1 instanceof AggUnaryOp ) {
													hi = _applyRewrite435(hi); // trace(-(a,$1:colSums(B))) => -(a,trace(colSums(B)))
												} else {
													hi = _applyRewrite38(hi); // sum(-(0.0,B)) => -(0.0,sum(B))
												}
											}
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite138(hi); // trace(-($1:t(A),b)) => trace(-(A,b))
											hi = _applyRewrite140(hi); // trace(-($1:t(A),B)) => trace(-(A,B))
											hi = _applyRewrite141(hi); // trace(-(A,$1:t(B))) => trace(-(A,B))
											hi = _applyRewrite177(hi); // sum(-($1:t(A),b)) => sum(-(A,b))
											hi = _applyRewrite434(hi); // trace(-($1:colSums(A),b)) => -(trace(colSums(A)),b)
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.PLUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite145(hi); // trace(+(b,$1:t(A))) => trace(+(A,b))
											hi = _applyRewrite182(hi); // sum(+(b,$1:t(A))) => sum(+(A,b))
											hi = _applyRewrite437(hi); // trace(+(b,$1:colSums(A))) => +(trace(colSums(A)),b)
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_0_0 instanceof ReorgOp ) {
												hi = _applyRewrite96(hi); // trace(+($1:t(A),A)) => +(trace(A),trace(A))
												hi = _applyRewrite142(hi); // trace(+($1:t(B),A)) => trace(+(A,B))
												hi = _applyRewrite144(hi); // trace(+($1:t(A),b)) => trace(+(A,b))
												hi = _applyRewrite181(hi); // sum(+($1:t(A),b)) => sum(+(A,b))
											} else if ( hi_0_0 instanceof AggUnaryOp ) {
												hi = _applyRewrite436(hi); // trace(+($1:colSums(A),b)) => +(trace(colSums(A)),b)
											} else {
												hi = _applyRewrite97(hi); // trace(+(A,$1:t(A))) => +(trace(A),trace(A))
												hi = _applyRewrite143(hi); // trace(+(B,$1:t(A))) => trace(+(A,B))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_0_0 instanceof BinaryOp ) {
												hi = _applyRewrite122(hi); // trace(/($1:*(a,B),C)) => *(a,trace(/(B,C)))
												hi = _applyRewrite123(hi); // trace(/($1:*(B,a),C)) => *(a,trace(/(B,C)))
												hi = _applyRewrite148(hi); // sum(/($1:*(a,B),C)) => *(a,sum(/(B,C)))
												hi = _applyRewrite149(hi); // sum(/($1:*(B,a),C)) => *(a,sum(/(B,C)))
											} else if ( hi_0_0 instanceof ReorgOp ) {
												hi = _applyRewrite370(hi); // trace(/($1:t(A),B)) => trace(/(A,B))
											} else {
												hi = _applyRewrite371(hi); // trace(/(A,t(B))) => trace(/(A,B))
											}
										} else if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite369(hi); // trace(/(a,t(B))) => trace(/(a,B))
											hi = _applyRewrite404(hi); // sum(/(a,t(B))) => sum(/(a,B))
										}
									}
								}
							}
						}
					}
				}
			}
		} else if ( hi.getDataType() == Types.DataType.MATRIX ) {
			if ( hi instanceof BinaryOp ) {
				if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.PLUS ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.SCALAR ) {
							if ( hi_0 instanceof BinaryOp ) {
								hi = _applyRewrite89(hi); // +(-(0.0,b),A) => -(A,b)
							} else {
								if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof UnaryOp ) {
										hi = _applyRewrite30(hi); // +(a,cast.MATRIX(0.0)) => cast.MATRIX(a)
										hi = _applyRewrite72(hi); // +(a,cast.MATRIX(b)) => cast.MATRIX(+(a,b))
									} else if ( hi_1 instanceof BinaryOp ) {
										if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
											if ( hi_1.getInput().size() == 2 ) {
												Hop hi_1_0 = hi_1.getInput(0);
												Hop hi_1_1 = hi_1.getInput(1);
												if ( hi_1_0.getDataType() == Types.DataType.SCALAR ) {
													hi = _applyRewrite44(hi); // +(a,-(0.0,B)) => -(a,B)
													hi = _applyRewrite55(hi); // +(a,-(b,C)) => -(+(a,b),C)
												} else if ( hi_1_0.getDataType() == Types.DataType.MATRIX ) {
													if ( hi_1_0 instanceof BinaryOp ) {
														if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.MINUS ) {
															hi = _applyRewrite299(hi); // +(a,-($1:-(b,D),C)) => -(+(a,b),+(C,D))
															hi = _applyRewrite340(hi); // +(b,-($1:-(A,c),D)) => +(A,-(-(b,c),D))
														} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.PLUS ) {
															hi = _applyRewrite314(hi); // +(b,-($1:+(c,A),D)) => +(A,-(+(b,c),D))
															hi = _applyRewrite315(hi); // +(b,-($1:+(A,c),D)) => +(A,-(+(b,c),D))
														} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.MULT ) {
															hi = _applyRewrite524(hi); // +(a,-($1:*(c,D),B)) => -(a,-*(B,c,D))
															hi = _applyRewrite525(hi); // +(a,-($1:*(D,c),B)) => -(a,-*(B,c,D))
														}
													} else {
														hi = _applyRewrite60(hi); // +(b,-(A,c)) => +(A,-(b,c))
														hi = _applyRewrite311(hi); // +(b,-(A,$1:-(D,c))) => +(A,-(+(b,c),D))
														hi = _applyRewrite320(hi); // +(c,-(A,$1:-(d,B))) => +(A,+(B,-(c,d)))
														hi = _applyRewrite343(hi); // +(b,-(A,$1:+(c,D))) => +(A,-(-(b,c),D))
														hi = _applyRewrite344(hi); // +(b,-(A,$1:+(D,c))) => +(A,-(-(b,c),D))
													}
												}
											}
										}
									} else if ( hi_1 instanceof ReorgOp ) {
										if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.REV ) {
											hi = _applyRewrite283(hi); // +(a,rev($1:-(b,C))) => -(+(a,b),rev(C))
											hi = _applyRewrite288(hi); // +(a,rev($1:-(C,b))) => +(-(a,b),rev(C))
											hi = _applyRewrite291(hi); // +(a,rev($1:+(b,C))) => +(+(a,b),rev(C))
											hi = _applyRewrite292(hi); // +(a,rev($1:+(C,b))) => +(+(a,b),rev(C))
										} else if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.TRANS ) {
											hi = _applyRewrite347(hi); // +(a,t($1:-(b,C))) => -(+(a,b),t(C))
											hi = _applyRewrite352(hi); // +(a,t($1:-(C,b))) => +(-(a,b),t(C))
											hi = _applyRewrite355(hi); // +(a,t($1:+(b,C))) => +(+(a,b),t(C))
											hi = _applyRewrite356(hi); // +(a,t($1:+(C,b))) => +(+(a,b),t(C))
										}
									} else {
										hi = _applyRewrite5(hi); // +(0.0,A) => A
									}
								}
							}
						} else if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof UnaryOp ) {
								hi = _applyRewrite29(hi); // +(cast.MATRIX(0.0),a) => cast.MATRIX(a)
								hi = _applyRewrite71(hi); // +(cast.MATRIX(a),b) => cast.MATRIX(+(a,b))
							} else if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
											if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
												hi = _applyRewrite43(hi); // +(-(0.0,B),a) => -(a,B)
												hi = _applyRewrite54(hi); // +(-(a,C),b) => -(+(a,b),C)
											} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
												if ( hi_0_0 instanceof BinaryOp ) {
													if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.MINUS ) {
														hi = _applyRewrite297(hi); // +(-($1:-(a,C),D),b) => -(+(a,b),+(C,D))
														hi = _applyRewrite337(hi); // +(-($1:-(A,c),D),b) => +(A,-(-(b,c),D))
													} else if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.PLUS ) {
														hi = _applyRewrite312(hi); // +(-($1:+(b,A),D),c) => +(A,-(+(b,c),D))
														hi = _applyRewrite313(hi); // +(-($1:+(A,b),D),c) => +(A,-(+(b,c),D))
													} else if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.MULT ) {
														hi = _applyRewrite522(hi); // +(-($1:*(c,D),B),a) => -(a,-*(B,c,D))
														hi = _applyRewrite523(hi); // +(-($1:*(D,c),B),a) => -(a,-*(B,c,D))
													}
												} else {
													hi = _applyRewrite59(hi); // +(-(A,c),b) => +(A,-(b,c))
													hi = _applyRewrite310(hi); // +(-(A,$1:-(D,b)),c) => +(A,-(+(b,c),D))
													hi = _applyRewrite319(hi); // +(-(A,$1:-(d,B)),c) => +(A,+(B,-(c,d)))
													hi = _applyRewrite341(hi); // +(-(A,$1:+(c,D)),b) => +(A,-(-(b,c),D))
													hi = _applyRewrite342(hi); // +(-(A,$1:+(D,c)),b) => +(A,-(-(b,c),D))
												}
											}
										} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof BinaryOp ) {
												hi = _applyRewrite298(hi); // +(-(a,D),-(b,C)) => -(+(a,b),+(C,D))
												hi = _applyRewrite304(hi); // +(-(B,c),-(A,d)) => +(A,-(B,+(c,d)))
												hi = _applyRewrite338(hi); // +(-(b,D),-(A,c)) => +(A,-(-(b,c),D))
												hi = _applyRewrite339(hi); // +(-(A,c),-(b,D)) => +(A,-(-(b,c),D))
											} else {
												if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
													hi = _applyRewrite47(hi); // +(-(0.0,B),A) => -(A,B)
													hi = _applyRewrite538(hi); // +(-(a,$1:*(c,D)),B) => +(a,-*(B,c,D))
													hi = _applyRewrite539(hi); // +(-(a,$1:*(D,c)),B) => +(a,-*(B,c,D))
												} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
													hi = _applyRewrite530(hi); // +(-($1:*(b,C),d),A) => -(+*(A,b,C),d)
													hi = _applyRewrite531(hi); // +(-($1:*(C,b),d),A) => -(+*(A,b,C),d)
													hi = _applyRewrite546(hi); // +(-($1:*(c,D),B),A) => -(A,-*(B,c,D))
													hi = _applyRewrite547(hi); // +(-($1:*(D,c),B),A) => -(A,-*(B,c,D))
												}
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof BinaryOp ) {
												hi = _applyRewrite124(hi); // +(*(C,A),*(B,A)) => *(A,+(B,C))
												hi = _applyRewrite125(hi); // +(*(B,A),*(A,C)) => *(A,+(B,C))
												hi = _applyRewrite126(hi); // +(*(A,C),*(B,A)) => *(A,+(B,C))
												hi = _applyRewrite127(hi); // +(*(A,C),*(A,B)) => *(A,+(B,C))
											} else {
												hi = _applyRewrite554(hi); // +(*($1:/(b,D),C),A) => +*(A,b,/(C,D))
												hi = _applyRewrite557(hi); // +(*(C,$1:/(b,D)),A) => +*(A,b,/(C,D))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									hi = _applyRewrite246(hi); // +(!=(rev(A),c),A) => +(A,!=(A,c))
									hi = _applyRewrite247(hi); // +(!=(c,rev(A)),A) => +(A,!=(A,c))
									hi = _applyRewrite254(hi); // +(!=(rev(A),C),A) => +(A,!=(A,C))
									hi = _applyRewrite255(hi); // +(!=(C,rev(A)),A) => +(A,!=(A,C))
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									hi = _applyRewrite555(hi); // +(/($1:*(b,C),D),A) => +*(A,b,/(C,D))
									hi = _applyRewrite556(hi); // +(/($1:*(C,b),D),A) => +*(A,b,/(C,D))
								}
							} else if ( hi_0 instanceof AggBinaryOp ) {
								if ( HopRewriteUtils.isMatrixMultiply(hi_0) ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof AggBinaryOp ) {
												hi = _applyRewrite94(hi); // +(%*%(B,C),%*%(A,C)) => %*%(+(A,B),C)
												hi = _applyRewrite95(hi); // +(%*%(A,C),%*%(A,B)) => %*%(A,+(B,C))
											} else {
												hi = _applyRewrite566(hi); // +(%*%($1:*(b,C),D),A) => +*(A,b,%*%(C,D))
												hi = _applyRewrite567(hi); // +(%*%($1:*(C,b),D),A) => +*(A,b,%*%(C,D))
												hi = _applyRewrite568(hi); // +(%*%(C,$1:*(b,D)),A) => +*(A,b,%*%(C,D))
												hi = _applyRewrite569(hi); // +(%*%(C,$1:*(D,b)),A) => +*(A,b,%*%(C,D))
											}
										}
									}
								}
							} else if ( hi_0 instanceof ReorgOp ) {
								if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.TRANS ) {
									if ( hi_0.getInput().size() == 1 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite192(hi); // +(t(B),t(A)) => t(+(A,B))
											hi = _applyRewrite512(hi); // +(t($1:*(b,C)),A) => +*(A,b,t(C))
											hi = _applyRewrite513(hi); // +(t($1:*(C,b)),A) => +*(A,b,t(C))
										} else if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite346(hi); // +(t($1:-(a,C)),b) => -(+(a,b),t(C))
											hi = _applyRewrite351(hi); // +(t($1:-(C,b)),a) => +(-(a,b),t(C))
											hi = _applyRewrite353(hi); // +(t($1:+(a,C)),b) => +(+(a,b),t(C))
											hi = _applyRewrite354(hi); // +(t($1:+(C,a)),b) => +(+(a,b),t(C))
										}
									}
								} else if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.REV ) {
									if ( hi_0.getInput().size() == 1 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite250(hi); // +(rev($1:!=(c,A)),A) => +(A,!=(A,c))
											hi = _applyRewrite251(hi); // +(rev($1:!=(A,c)),A) => +(A,!=(A,c))
											hi = _applyRewrite503(hi); // +(rev($1:*(b,C)),A) => +*(A,b,rev(C))
											hi = _applyRewrite504(hi); // +(rev($1:*(C,b)),A) => +*(A,b,rev(C))
										} else if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite282(hi); // +(rev($1:-(a,C)),b) => -(+(a,b),rev(C))
											hi = _applyRewrite287(hi); // +(rev($1:-(C,b)),a) => +(-(a,b),rev(C))
											hi = _applyRewrite289(hi); // +(rev($1:+(a,C)),b) => +(+(a,b),rev(C))
											hi = _applyRewrite290(hi); // +(rev($1:+(C,a)),b) => +(+(a,b),rev(C))
										}
									}
								}
							} else {
								if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
									hi = _applyRewrite6(hi); // +(A,0.0) => A
									hi = _applyRewrite90(hi); // +(A,-(0.0,b)) => -(A,b)
								} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof BinaryOp ) {
										if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
											if ( hi_1.getInput().size() == 2 ) {
												Hop hi_1_0 = hi_1.getInput(0);
												Hop hi_1_1 = hi_1.getInput(1);
												if ( hi_1_0.getDataType() == Types.DataType.SCALAR ) {
													hi = _applyRewrite48(hi); // +(A,-(0.0,B)) => -(A,B)
													hi = _applyRewrite540(hi); // +(B,-(a,$1:*(c,D))) => +(a,-*(B,c,D))
													hi = _applyRewrite541(hi); // +(B,-(a,$1:*(D,c))) => +(a,-*(B,c,D))
												} else if ( hi_1_0.getDataType() == Types.DataType.MATRIX ) {
													hi = _applyRewrite532(hi); // +(A,-($1:*(b,C),d)) => -(+*(A,b,C),d)
													hi = _applyRewrite533(hi); // +(A,-($1:*(C,b),d)) => -(+*(A,b,C),d)
													hi = _applyRewrite548(hi); // +(A,-($1:*(c,D),B)) => -(A,-*(B,c,D))
													hi = _applyRewrite549(hi); // +(A,-($1:*(D,c),B)) => -(A,-*(B,c,D))
												}
											}
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.NOTEQUAL ) {
											hi = _applyRewrite248(hi); // +(A,!=(rev(A),c)) => +(A,!=(A,c))
											hi = _applyRewrite249(hi); // +(A,!=(c,rev(A))) => +(A,!=(A,c))
											hi = _applyRewrite256(hi); // +(A,!=(rev(A),C)) => +(A,!=(A,C))
											hi = _applyRewrite257(hi); // +(A,!=(C,rev(A))) => +(A,!=(A,C))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.DIV ) {
											hi = _applyRewrite558(hi); // +(A,/($1:*(b,C),D)) => +*(A,b,/(C,D))
											hi = _applyRewrite560(hi); // +(A,/($1:*(C,b),D)) => +*(A,b,/(C,D))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MULT ) {
											hi = _applyRewrite559(hi); // +(A,*($1:/(b,D),C)) => +*(A,b,/(C,D))
											hi = _applyRewrite561(hi); // +(A,*(C,$1:/(b,D))) => +*(A,b,/(C,D))
										}
									} else if ( hi_1 instanceof ReorgOp ) {
										hi = _applyRewrite252(hi); // +(A,rev($1:!=(c,A))) => +(A,!=(A,c))
										hi = _applyRewrite253(hi); // +(A,rev($1:!=(A,c))) => +(A,!=(A,c))
										hi = _applyRewrite505(hi); // +(A,rev($1:*(C,b))) => +*(A,b,rev(C))
										hi = _applyRewrite514(hi); // +(A,t($1:*(b,C))) => +*(A,b,t(C))
										hi = _applyRewrite515(hi); // +(A,t($1:*(C,b))) => +*(A,b,t(C))
									} else if ( hi_1 instanceof AggUnaryOp ) {
										hi = _applyRewrite441(hi); // +(A,colSums($1:rev(A))) => +(A,colSums(A))
									} else if ( hi_1 instanceof AggBinaryOp ) {
										hi = _applyRewrite570(hi); // +(A,%*%($1:*(b,C),D)) => +*(A,b,%*%(C,D))
										hi = _applyRewrite571(hi); // +(A,%*%($1:*(C,b),D)) => +*(A,b,%*%(C,D))
										hi = _applyRewrite572(hi); // +(A,%*%(C,$1:*(b,D))) => +*(A,b,%*%(C,D))
										hi = _applyRewrite573(hi); // +(A,%*%(C,$1:*(D,b))) => +*(A,b,%*%(C,D))
									}
								}
							}
						}
					}
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.DIV ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.SCALAR ) {
							hi = _applyRewrite10(hi); // /(0.0,A) => const(A,0.0)
							hi = _applyRewrite75(hi); // /(a,cast.MATRIX(b)) => cast.MATRIX(/(a,b))
							hi = _applyRewrite93(hi); // /(-(a,0.0),B) => /(a,B)
						} else if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof ReorgOp ) {
								hi = _applyRewrite409(hi); // /(t(A),t(B)) => t(/(A,B))
								hi = _applyRewrite421(hi); // /(rev($1:!=(A,b)),A) => /(!=(A,b),A)
							} else {
								if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
									hi = _applyRewrite13(hi); // /(A,c) => *(A,/(1.0,c))
								} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof ReorgOp ) {
										hi = _applyRewrite422(hi); // /(A,rev(!=(c,A))) => /(A,!=(A,c))
										hi = _applyRewrite423(hi); // /(A,rev(!=(A,c))) => /(A,!=(A,c))
									} else if ( hi_1 instanceof BinaryOp ) {
										hi = _applyRewrite424(hi); // /(A,!=(rev(A),c)) => /(A,!=(A,c))
										hi = _applyRewrite425(hi); // /(A,!=(c,rev(A))) => /(A,!=(A,c))
										hi = _applyRewrite426(hi); // /(A,!=(rev(A),C)) => /(A,!=(A,C))
										hi = _applyRewrite427(hi); // /(A,!=(C,rev(A))) => /(A,!=(A,C))
									}
								}
							}
						}
					}
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.MULT ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.SCALAR ) {
							if ( hi_0 instanceof BinaryOp ) {
								hi = _applyRewrite91(hi); // *(-(b,0.0),A) => *(A,b)
							} else {
								if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof UnaryOp ) {
										hi = _applyRewrite26(hi); // *(a,cast.MATRIX(0.0)) => cast.MATRIX(0.0)
										hi = _applyRewrite28(hi); // *(a,cast.MATRIX(1.0)) => cast.MATRIX(a)
										hi = _applyRewrite74(hi); // *(a,cast.MATRIX(b)) => cast.MATRIX(*(a,b))
									} else if ( hi_1 instanceof BinaryOp ) {
										hi = _applyRewrite33(hi); // *(a,/(1.0,B)) => /(a,B)
										hi = _applyRewrite37(hi); // *(a,/(b,C)) => /(*(a,b),C)
										hi = _applyRewrite172(hi); // *(a,/($1:*(b,C),D)) => *(*(a,b),/(C,D))
										hi = _applyRewrite173(hi); // *(a,/($1:*(C,b),D)) => *(*(a,b),/(C,D))
										hi = _applyRewrite176(hi); // *(a,/($1:/(b,C),D)) => /(/(*(a,b),C),D)
									} else if ( hi_1 instanceof ReorgOp ) {
										if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.TRANS ) {
											hi = _applyRewrite130(hi); // *(a,t($1:*(b,C))) => *(*(a,b),t(C))
											hi = _applyRewrite131(hi); // *(a,t($1:*(C,b))) => *(*(a,b),t(C))
											hi = _applyRewrite153(hi); // *(a,t($1:/(b,C))) => /(*(a,b),t(C))
										} else if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.REV ) {
											hi = _applyRewrite134(hi); // *(a,rev($1:*(b,C))) => *(*(a,b),rev(C))
											hi = _applyRewrite135(hi); // *(a,rev($1:*(C,b))) => *(*(a,b),rev(C))
											hi = _applyRewrite155(hi); // *(a,rev($1:/(b,C))) => /(*(a,b),rev(C))
										}
									} else if ( hi_1 instanceof AggBinaryOp ) {
										hi = _applyRewrite450(hi); // *(a,%*%($1:*(b,C),D)) => *(*(a,b),%*%(C,D))
										hi = _applyRewrite451(hi); // *(a,%*%($1:*(C,b),D)) => *(*(a,b),%*%(C,D))
										hi = _applyRewrite452(hi); // *(a,%*%(C,$1:*(b,D))) => *(*(a,b),%*%(C,D))
										hi = _applyRewrite456(hi); // *(a,%*%($1:/(b,C),D)) => %*%(/(*(a,b),C),D)
										hi = _applyRewrite460(hi); // *(b,%*%(A,$1:/(c,D))) => %*%(A,/(*(b,c),D))
									} else if ( hi_1 instanceof AggUnaryOp ) {
										hi = _applyRewrite495(hi); // *(a,colSums($1:/(b,C))) => colSums(/(*(a,b),C))
										hi = _applyRewrite497(hi); // *(a,rowSums($1:/(b,C))) => rowSums(/(*(a,b),C))
									} else {
										hi = _applyRewrite11(hi); // *(0.0,A) => const(A,0.0)
									}
								}
							}
						} else if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof UnaryOp ) {
								hi = _applyRewrite25(hi); // *(cast.MATRIX(0.0),a) => cast.MATRIX(0.0)
								hi = _applyRewrite27(hi); // *(cast.MATRIX(1.0),a) => cast.MATRIX(a)
								hi = _applyRewrite73(hi); // *(cast.MATRIX(a),b) => cast.MATRIX(*(a,b))
							} else if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite32(hi); // *(/(1.0,B),a) => /(a,B)
											hi = _applyRewrite36(hi); // *(/(a,C),b) => /(*(a,b),C)
											hi = _applyRewrite170(hi); // *(/($1:*(a,C),D),b) => *(*(a,b),/(C,D))
											hi = _applyRewrite171(hi); // *(/($1:*(C,a),D),b) => *(*(a,b),/(C,D))
											hi = _applyRewrite174(hi); // *(/($1:/(a,C),D),b) => /(/(*(a,b),C),D)
										} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite34(hi); // *(/(1.0,B),A) => /(A,B)
											hi = _applyRewrite175(hi); // *(/(a,C),/(b,D)) => /(/(*(a,b),C),D)
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									hi = _applyRewrite392(hi); // *(!=(rev(A),c),A) => *(A,!=(A,c))
									hi = _applyRewrite393(hi); // *(!=(c,rev(A)),A) => *(A,!=(A,c))
									hi = _applyRewrite400(hi); // *(!=(rev(A),C),A) => *(A,!=(A,C))
									hi = _applyRewrite401(hi); // *(!=(C,rev(A)),A) => *(A,!=(A,C))
								}
							} else if ( hi_0 instanceof ReorgOp ) {
								if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.TRANS ) {
									hi = _applyRewrite128(hi); // *(t($1:*(a,C)),b) => *(*(a,b),t(C))
									hi = _applyRewrite129(hi); // *(t($1:*(C,a)),b) => *(*(a,b),t(C))
									hi = _applyRewrite152(hi); // *(t($1:/(a,C)),b) => /(*(a,b),t(C))
									hi = _applyRewrite372(hi); // *(t(A),t(B)) => t(*(A,B))
								} else if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.REV ) {
									hi = _applyRewrite132(hi); // *(rev($1:*(a,C)),b) => *(*(a,b),rev(C))
									hi = _applyRewrite133(hi); // *(rev($1:*(C,a)),b) => *(*(a,b),rev(C))
									hi = _applyRewrite154(hi); // *(rev($1:/(a,C)),b) => /(*(a,b),rev(C))
									hi = _applyRewrite396(hi); // *(rev($1:!=(c,A)),A) => *(A,!=(A,c))
									hi = _applyRewrite397(hi); // *(rev($1:!=(A,c)),A) => *(A,!=(A,c))
								}
							} else if ( hi_0 instanceof AggBinaryOp ) {
								hi = _applyRewrite447(hi); // *(%*%($1:*(a,C),D),b) => *(*(a,b),%*%(C,D))
								hi = _applyRewrite448(hi); // *(%*%($1:*(C,a),D),b) => *(*(a,b),%*%(C,D))
								hi = _applyRewrite449(hi); // *(%*%(C,$1:*(D,a)),b) => *(*(a,b),%*%(C,D))
								hi = _applyRewrite455(hi); // *(%*%($1:/(a,C),D),b) => %*%(/(*(a,b),C),D)
								hi = _applyRewrite459(hi); // *(%*%(A,$1:/(b,D)),c) => %*%(A,/(*(b,c),D))
							} else if ( hi_0 instanceof AggUnaryOp ) {
								hi = _applyRewrite494(hi); // *(colSums($1:/(a,C)),b) => colSums(/(*(a,b),C))
								hi = _applyRewrite496(hi); // *(rowSums($1:/(a,C)),b) => rowSums(/(*(a,b),C))
							} else {
								if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
									hi = _applyRewrite12(hi); // *(A,0.0) => const(A,0.0)
									hi = _applyRewrite92(hi); // *(A,-(b,0.0)) => *(A,b)
								} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof BinaryOp ) {
										hi = _applyRewrite35(hi); // *(A,/(1.0,B)) => /(A,B)
										hi = _applyRewrite394(hi); // *(A,!=(rev(A),c)) => *(A,!=(A,c))
										hi = _applyRewrite395(hi); // *(A,!=(c,rev(A))) => *(A,!=(A,c))
										hi = _applyRewrite402(hi); // *(A,!=(rev(A),C)) => *(A,!=(A,C))
										hi = _applyRewrite403(hi); // *(A,!=(C,rev(A))) => *(A,!=(A,C))
									} else if ( hi_1 instanceof ReorgOp ) {
										hi = _applyRewrite398(hi); // *(A,rev($1:!=(c,A))) => *(A,!=(A,c))
										hi = _applyRewrite399(hi); // *(A,rev($1:!=(A,c))) => *(A,!=(A,c))
									} else if ( hi_1 instanceof AggUnaryOp ) {
										hi = _applyRewrite442(hi); // *(A,colSums($1:rev(A))) => *(A,colSums(A))
									}
								}
							}
						}
					}
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.MINUS ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.SCALAR ) {
							if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
								if ( hi_1 instanceof BinaryOp ) {
									if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
										if ( hi_1.getInput().size() == 2 ) {
											Hop hi_1_0 = hi_1.getInput(0);
											Hop hi_1_1 = hi_1.getInput(1);
											if ( hi_1_0.getDataType() == Types.DataType.MATRIX ) {
												if ( hi_1_0 instanceof BinaryOp ) {
													if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.MINUS ) {
														hi = _applyRewrite305(hi); // -(b,-($1:-(D,c),A)) => +(A,-(+(b,c),D))
														hi = _applyRewrite316(hi); // -(c,-($1:-(d,B),A)) => +(A,+(B,-(c,d)))
													} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.PLUS ) {
														hi = _applyRewrite327(hi); // -(b,-($1:+(c,D),A)) => +(A,-(-(b,c),D))
														hi = _applyRewrite328(hi); // -(b,-($1:+(D,c),A)) => +(A,-(-(b,c),D))
													} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.MULT ) {
														hi = _applyRewrite534(hi); // -(a,-($1:*(c,D),B)) => +(a,-*(B,c,D))
														hi = _applyRewrite535(hi); // -(a,-($1:*(D,c),B)) => +(a,-*(B,c,D))
													}
												} else {
													if ( hi_1_1.getDataType() == Types.DataType.SCALAR ) {
														hi = _applyRewrite42(hi); // -(0.0,-(B,a)) => -(a,B)
														hi = _applyRewrite53(hi); // -(a,-(C,b)) => -(+(a,b),C)
													} else if ( hi_1_1.getDataType() == Types.DataType.MATRIX ) {
														hi = _applyRewrite46(hi); // -(0.0,-(B,A)) => -(A,B)
														hi = _applyRewrite294(hi); // -(a,-(C,$1:-(b,D))) => -(+(a,b),+(C,D))
														hi = _applyRewrite306(hi); // -(b,-(D,$1:+(c,A))) => +(A,-(+(b,c),D))
														hi = _applyRewrite307(hi); // -(b,-(D,$1:+(A,c))) => +(A,-(+(b,c),D))
														hi = _applyRewrite324(hi); // -(b,-(D,$1:-(A,c))) => +(A,-(-(b,c),D))
													}
												}
											} else if ( hi_1_0.getDataType() == Types.DataType.SCALAR ) {
												hi = _applyRewrite45(hi); // -(0.0,-(b,A)) => -(A,b)
												hi = _applyRewrite58(hi); // -(b,-(c,A)) => +(A,-(b,c))
											}
										}
									} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.PLUS ) {
										if ( hi_1.getInput().size() == 2 ) {
											Hop hi_1_0 = hi_1.getInput(0);
											Hop hi_1_1 = hi_1.getInput(1);
											if ( hi_1_0.getDataType() == Types.DataType.SCALAR ) {
												hi = _applyRewrite50(hi); // -(a,+(b,C)) => -(-(a,b),C)
											} else if ( hi_1_0.getDataType() == Types.DataType.MATRIX ) {
												hi = _applyRewrite51(hi); // -(a,+(C,b)) => -(-(a,b),C)
												hi = _applyRewrite295(hi); // -(a,+($1:-(D,b),C)) => -(+(a,b),+(C,D))
												hi = _applyRewrite296(hi); // -(a,+(D,$1:-(C,b))) => -(+(a,b),+(C,D))
												hi = _applyRewrite335(hi); // -(b,+($1:-(c,A),D)) => +(A,-(-(b,c),D))
												hi = _applyRewrite336(hi); // -(b,+(D,$1:-(c,A))) => +(A,-(-(b,c),D))
											}
										}
									} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MULT ) {
										hi = _applyRewrite86(hi); // -(0.0,*(b,A)) => -*(const(A,0.0),b,A)
										hi = _applyRewrite87(hi); // -(0.0,*(A,b)) => -*(const(A,0.0),b,A)
									}
								} else if ( hi_1 instanceof UnaryOp ) {
									hi = _applyRewrite70(hi); // -(a,cast.MATRIX(b)) => cast.MATRIX(-(a,b))
								} else if ( hi_1 instanceof ReorgOp ) {
									if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.TRANS ) {
										hi = _applyRewrite267(hi); // -(a,t($1:+(b,C))) => -(-(a,b),t(C))
										hi = _applyRewrite268(hi); // -(a,t($1:+(C,b))) => -(-(a,b),t(C))
										hi = _applyRewrite345(hi); // -(a,t($1:-(C,b))) => -(+(a,b),t(C))
										hi = _applyRewrite350(hi); // -(a,t($1:-(b,C))) => +(-(a,b),t(C))
									} else if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.REV ) {
										hi = _applyRewrite271(hi); // -(a,rev($1:+(b,C))) => -(-(a,b),rev(C))
										hi = _applyRewrite272(hi); // -(a,rev($1:+(C,b))) => -(-(a,b),rev(C))
										hi = _applyRewrite281(hi); // -(a,rev($1:-(C,b))) => -(+(a,b),rev(C))
										hi = _applyRewrite284(hi); // -(a,rev($1:-(b,C))) => +(-(a,b),rev(C))
									}
								}
							}
						} else if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
											if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
												if ( hi_0_0 instanceof BinaryOp ) {
													hi = _applyRewrite273(hi); // -(-($1:-(a,D),C),b) => -(-(a,b),+(C,D))
													hi = _applyRewrite276(hi); // -(-($1:-(A,c),B),d) => -(A,+(B,+(c,d)))
													hi = _applyRewrite325(hi); // -(-($1:+(b,A),D),c) => +(A,-(-(b,c),D))
													hi = _applyRewrite326(hi); // -(-($1:+(A,b),D),c) => +(A,-(-(b,c),D))
												} else {
													hi = _applyRewrite49(hi); // -(-(A,b),c) => -(A,+(b,c))
													hi = _applyRewrite277(hi); // -(-(A,$1:+(c,B)),d) => -(A,+(B,+(c,d)))
													hi = _applyRewrite278(hi); // -(-(A,$1:+(B,c)),d) => -(A,+(B,+(c,d)))
													hi = _applyRewrite300(hi); // -(-(A,$1:-(c,B)),d) => +(A,-(B,+(c,d)))
													hi = _applyRewrite321(hi); // -(-(A,$1:-(D,b)),c) => +(A,-(-(b,c),D))
												}
											} else if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
												hi = _applyRewrite52(hi); // -(-(a,C),b) => -(-(a,b),C)
											}
										} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof BinaryOp ) {
												if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.PLUS ) {
													hi = _applyRewrite274(hi); // -(-(a,C),+(b,D)) => -(-(a,b),+(C,D))
													hi = _applyRewrite275(hi); // -(-(a,D),+(C,b)) => -(-(a,b),+(C,D))
													hi = _applyRewrite279(hi); // -(-(A,c),+(d,B)) => -(A,+(B,+(c,d)))
													hi = _applyRewrite280(hi); // -(-(A,c),+(B,d)) => -(A,+(B,+(c,d)))
												} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
													hi = _applyRewrite293(hi); // -(-(a,C),-(D,b)) => -(+(a,b),+(C,D))
													hi = _applyRewrite301(hi); // -(-(B,c),-(d,A)) => +(A,-(B,+(c,d)))
													hi = _applyRewrite322(hi); // -(-(b,D),-(c,A)) => +(A,-(-(b,c),D))
													hi = _applyRewrite323(hi); // -(-(A,c),-(D,b)) => +(A,-(-(b,c),D))
												}
											} else {
												hi = _applyRewrite506(hi); // -(-(a,$1:*(c,D)),B) => -(a,+*(B,c,D))
												hi = _applyRewrite507(hi); // -(-(a,$1:*(D,c)),B) => -(a,+*(B,c,D))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.PLUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
											if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
												hi = _applyRewrite56(hi); // -(+(b,A),c) => +(A,-(b,c))
											} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
												hi = _applyRewrite57(hi); // -(+(A,b),c) => +(A,-(b,c))
												hi = _applyRewrite302(hi); // -(+($1:-(B,c),A),d) => +(A,-(B,+(c,d)))
												hi = _applyRewrite303(hi); // -(+(A,$1:-(B,c)),d) => +(A,-(B,+(c,d)))
												hi = _applyRewrite329(hi); // -(+($1:-(b,D),A),c) => +(A,-(-(b,c),D))
												hi = _applyRewrite334(hi); // -(+(A,$1:-(b,D)),c) => +(A,-(-(b,c),D))
											}
										} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof BinaryOp ) {
												if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
													hi = _applyRewrite308(hi); // -(+(b,A),-(D,c)) => +(A,-(+(b,c),D))
													hi = _applyRewrite309(hi); // -(+(A,b),-(D,c)) => +(A,-(+(b,c),D))
													hi = _applyRewrite317(hi); // -(+(c,B),-(d,A)) => +(A,+(B,-(c,d)))
													hi = _applyRewrite318(hi); // -(+(B,c),-(d,A)) => +(A,+(B,-(c,d)))
												} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.PLUS ) {
													hi = _applyRewrite330(hi); // -(+(b,A),+(c,D)) => +(A,-(-(b,c),D))
													hi = _applyRewrite331(hi); // -(+(b,A),+(D,c)) => +(A,-(-(b,c),D))
													hi = _applyRewrite332(hi); // -(+(A,b),+(c,D)) => +(A,-(-(b,c),D))
													hi = _applyRewrite333(hi); // -(+(A,b),+(D,c)) => +(A,-(-(b,c),D))
												}
											} else {
												hi = _applyRewrite516(hi); // -(+($1:*(c,D),a),B) => -(a,-*(B,c,D))
												hi = _applyRewrite517(hi); // -(+($1:*(D,c),a),B) => -(a,-*(B,c,D))
												hi = _applyRewrite518(hi); // -(+(a,$1:*(c,D)),B) => -(a,-*(B,c,D))
												hi = _applyRewrite519(hi); // -(+(a,$1:*(D,c)),B) => -(a,-*(B,c,D))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof BinaryOp ) {
												if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
													if ( hi_1.getInput().size() == 2 ) {
														Hop hi_1_0 = hi_1.getInput(0);
														Hop hi_1_1 = hi_1.getInput(1);
														if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
															hi = _applyRewrite520(hi); // -(*(c,D),-(B,a)) => -(a,-*(B,c,D))
															hi = _applyRewrite528(hi); // -(*(b,C),-(d,A)) => -(+*(A,b,C),d)
															hi = _applyRewrite544(hi); // -(*(c,D),-(B,A)) => -(A,-*(B,c,D))
														} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
															hi = _applyRewrite521(hi); // -(*(D,c),-(B,a)) => -(a,-*(B,c,D))
															hi = _applyRewrite529(hi); // -(*(C,b),-(d,A)) => -(+*(A,b,C),d)
															hi = _applyRewrite545(hi); // -(*(D,c),-(B,A)) => -(A,-*(B,c,D))
														}
													}
												}
											}
										}
									}
								}
							} else if ( hi_0 instanceof UnaryOp ) {
								hi = _applyRewrite69(hi); // -(cast.MATRIX(a),b) => cast.MATRIX(-(a,b))
							} else if ( hi_0 instanceof ReorgOp ) {
								if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.TRANS ) {
									hi = _applyRewrite191(hi); // -(t(A),t(B)) => t(-(A,B))
									hi = _applyRewrite265(hi); // -(t($1:-(A,b)),c) => -(t(A),+(b,c))
									hi = _applyRewrite266(hi); // -(t($1:-(a,C)),b) => -(-(a,b),t(C))
									hi = _applyRewrite348(hi); // -(t($1:+(a,C)),b) => +(-(a,b),t(C))
									hi = _applyRewrite349(hi); // -(t($1:+(C,a)),b) => +(-(a,b),t(C))
								} else if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.REV ) {
									hi = _applyRewrite258(hi); // -(rev($1:!=(A,b)),A) => -(!=(A,b),A)
									hi = _applyRewrite269(hi); // -(rev($1:-(A,b)),c) => -(rev(A),+(b,c))
									hi = _applyRewrite270(hi); // -(rev($1:-(a,C)),b) => -(-(a,b),rev(C))
									hi = _applyRewrite285(hi); // -(rev($1:+(a,C)),b) => +(-(a,b),rev(C))
									hi = _applyRewrite286(hi); // -(rev($1:+(C,a)),b) => +(-(a,b),rev(C))
								}
							} else {
								if ( hi_1.getDataType() == Types.DataType.SCALAR ) {
									hi = _applyRewrite88(hi); // -(A,-(b,0.0)) => -(A,b)
								} else if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof BinaryOp ) {
										if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.NOTEQUAL ) {
											hi = _applyRewrite259(hi); // -(A,!=(rev(A),c)) => -(A,!=(A,c))
											hi = _applyRewrite260(hi); // -(A,!=(c,rev(A))) => -(A,!=(A,c))
											hi = _applyRewrite263(hi); // -(A,!=(rev(A),C)) => -(A,!=(A,C))
											hi = _applyRewrite264(hi); // -(A,!=(C,rev(A))) => -(A,!=(A,C))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.PLUS ) {
											hi = _applyRewrite508(hi); // -(A,+($1:*(b,C),d)) => -(-*(A,b,C),d)
											hi = _applyRewrite509(hi); // -(A,+($1:*(C,b),d)) => -(-*(A,b,C),d)
											hi = _applyRewrite510(hi); // -(A,+(d,$1:*(b,C))) => -(-*(A,b,C),d)
											hi = _applyRewrite511(hi); // -(A,+(d,$1:*(C,b))) => -(-*(A,b,C),d)
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
											if ( hi_1.getInput().size() == 2 ) {
												Hop hi_1_0 = hi_1.getInput(0);
												Hop hi_1_1 = hi_1.getInput(1);
												if ( hi_1_0.getDataType() == Types.DataType.SCALAR ) {
													hi = _applyRewrite526(hi); // -(A,-(d,$1:*(b,C))) => -(+*(A,b,C),d)
													hi = _applyRewrite527(hi); // -(A,-(d,$1:*(C,b))) => -(+*(A,b,C),d)
												} else if ( hi_1_0.getDataType() == Types.DataType.MATRIX ) {
													hi = _applyRewrite536(hi); // -(B,-($1:*(c,D),a)) => +(a,-*(B,c,D))
													hi = _applyRewrite537(hi); // -(B,-($1:*(D,c),a)) => +(a,-*(B,c,D))
													hi = _applyRewrite542(hi); // -(B,-($1:*(c,D),A)) => +(A,-*(B,c,D))
													hi = _applyRewrite543(hi); // -(B,-($1:*(D,c),A)) => +(A,-*(B,c,D))
												}
											}
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MULT ) {
											hi = _applyRewrite550(hi); // -(A,*($1:/(b,D),C)) => -*(A,b,/(C,D))
											hi = _applyRewrite551(hi); // -(A,*(C,$1:/(b,D))) => -*(A,b,/(C,D))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.DIV ) {
											hi = _applyRewrite552(hi); // -(A,/($1:*(b,C),D)) => -*(A,b,/(C,D))
											hi = _applyRewrite553(hi); // -(A,/($1:*(C,b),D)) => -*(A,b,/(C,D))
										}
									} else if ( hi_1 instanceof ReorgOp ) {
										if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.REV ) {
											hi = _applyRewrite261(hi); // -(A,rev($1:!=(c,A))) => -(A,!=(A,c))
											hi = _applyRewrite262(hi); // -(A,rev($1:!=(A,c))) => -(A,!=(A,c))
											hi = _applyRewrite499(hi); // -(A,rev($1:*(b,C))) => -*(A,b,rev(C))
											hi = _applyRewrite500(hi); // -(A,rev($1:*(C,b))) => -*(A,b,rev(C))
										} else if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.TRANS ) {
											hi = _applyRewrite501(hi); // -(A,t($1:*(b,C))) => -*(A,b,t(C))
											hi = _applyRewrite502(hi); // -(A,t($1:*(C,b))) => -*(A,b,t(C))
										}
									} else if ( hi_1 instanceof AggBinaryOp ) {
										hi = _applyRewrite562(hi); // -(A,%*%($1:*(b,C),D)) => -*(A,b,%*%(C,D))
										hi = _applyRewrite563(hi); // -(A,%*%($1:*(C,b),D)) => -*(A,b,%*%(C,D))
										hi = _applyRewrite564(hi); // -(A,%*%(C,$1:*(b,D))) => -*(A,b,%*%(C,D))
										hi = _applyRewrite565(hi); // -(A,%*%(C,$1:*(D,b))) => -*(A,b,%*%(C,D))
									}
								}
							}
						}
					}
				} else if ( (( BinaryOp ) hi ).getOp() == Types.OpOp2.NOTEQUAL ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof ReorgOp ) {
								if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.TRANS ) {
									hi = _applyRewrite185(hi); // !=(t(A),t(B)) => t(!=(A,B))
									hi = _applyRewrite430(hi); // !=(t(A),colSums(A)) => !=(A,cast.MATRIX(sum(A)))
								} else if ( (( ReorgOp ) hi_0 ).getOp() == Types.ReOrgOp.REV ) {
									if ( hi_0.getInput().size() == 1 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof ReorgOp ) {
												hi = _applyRewrite186(hi); // !=(rev(A),rev(A)) => rev(!=(A,A))
											} else {
												if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
													if ( hi_0_0 instanceof BinaryOp ) {
														if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.MINUS ) {
															hi = _applyRewrite193(hi); // !=(rev(-(b,A)),A) => !=(A,-(b,A))
															hi = _applyRewrite198(hi); // !=(rev(-(A,c)),A) => !=(A,-(A,c))
														} else if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.PLUS ) {
															hi = _applyRewrite212(hi); // !=(rev(+(c,A)),A) => !=(A,+(A,c))
															hi = _applyRewrite213(hi); // !=(rev(+(A,c)),A) => !=(A,+(A,c))
														} else if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
															hi = _applyRewrite232(hi); // !=(rev(!=(c,A)),A) => !=(A,!=(A,c))
															hi = _applyRewrite233(hi); // !=(rev(!=(A,c)),A) => !=(A,!=(A,c))
														} else if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.MULT ) {
															hi = _applyRewrite378(hi); // !=(rev(*(c,A)),A) => !=(A,*(A,c))
															hi = _applyRewrite379(hi); // !=(rev(*(A,c)),A) => !=(A,*(A,c))
														} else if ( (( BinaryOp ) hi_0_0 ).getOp() == Types.OpOp2.DIV ) {
															hi = _applyRewrite413(hi); // !=(rev(/(b,A)),A) => !=(A,/(b,A))
														}
													} else if ( hi_0_0 instanceof AggBinaryOp ) {
														hi = _applyRewrite466(hi); // !=(rev(%*%(A,C)),A) => !=(A,%*%(A,C))
													}
												}
											}
										}
									}
								}
							} else if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof ReorgOp ) {
												hi = _applyRewrite196(hi); // !=(-(b,A),rev(A)) => !=(A,-(b,A))
												hi = _applyRewrite203(hi); // !=(-(B,A),rev(A)) => !=(A,-(B,A))
												hi = _applyRewrite206(hi); // !=(-(A,C),rev(A)) => !=(A,-(A,C))
											} else {
												hi = _applyRewrite195(hi); // !=(-(b,rev(A)),A) => !=(A,-(b,A))
												hi = _applyRewrite200(hi); // !=(-(rev(A),c),A) => !=(A,-(A,c))
												hi = _applyRewrite202(hi); // !=(-(B,rev(A)),A) => !=(A,-(B,A))
												hi = _applyRewrite205(hi); // !=(-(rev(A),C),A) => !=(A,-(A,C))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.PLUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof ReorgOp ) {
												hi = _applyRewrite218(hi); // !=(+(c,A),rev(A)) => !=(A,+(A,c))
												hi = _applyRewrite223(hi); // !=(+(C,A),rev(A)) => !=(A,+(A,C))
												hi = _applyRewrite224(hi); // !=(+(A,C),rev(A)) => !=(A,+(A,C))
											} else {
												hi = _applyRewrite216(hi); // !=(+(rev(A),c),A) => !=(A,+(A,c))
												hi = _applyRewrite217(hi); // !=(+(c,rev(A)),A) => !=(A,+(A,c))
												hi = _applyRewrite221(hi); // !=(+(rev(A),C),A) => !=(A,+(A,C))
												hi = _applyRewrite222(hi); // !=(+(C,rev(A)),A) => !=(A,+(A,C))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof ReorgOp ) {
												hi = _applyRewrite229(hi); // !=(!=(c,A),rev(A)) => !=(A,!=(A,c))
												hi = _applyRewrite238(hi); // !=(!=(C,A),rev(A)) => !=(A,!=(A,C))
												hi = _applyRewrite239(hi); // !=(!=(A,C),rev(A)) => !=(A,!=(A,C))
											} else {
												hi = _applyRewrite227(hi); // !=(!=(rev(A),c),A) => !=(A,!=(A,c))
												hi = _applyRewrite228(hi); // !=(!=(c,rev(A)),A) => !=(A,!=(A,c))
												hi = _applyRewrite236(hi); // !=(!=(rev(A),C),A) => !=(A,!=(A,C))
												hi = _applyRewrite237(hi); // !=(!=(C,rev(A)),A) => !=(A,!=(A,C))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof ReorgOp ) {
												hi = _applyRewrite375(hi); // !=(*(c,A),rev(A)) => !=(A,*(A,c))
												hi = _applyRewrite384(hi); // !=(*(C,A),rev(A)) => !=(A,*(A,C))
												hi = _applyRewrite385(hi); // !=(*(A,C),rev(A)) => !=(A,*(A,C))
											} else {
												hi = _applyRewrite373(hi); // !=(*(rev(A),c),A) => !=(A,*(A,c))
												hi = _applyRewrite374(hi); // !=(*(c,rev(A)),A) => !=(A,*(A,c))
												hi = _applyRewrite382(hi); // !=(*(rev(A),C),A) => !=(A,*(A,C))
												hi = _applyRewrite383(hi); // !=(*(C,rev(A)),A) => !=(A,*(A,C))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof ReorgOp ) {
												hi = _applyRewrite411(hi); // !=(/(b,A),rev(A)) => !=(A,/(b,A))
												hi = _applyRewrite416(hi); // !=(/(B,A),rev(A)) => !=(A,/(B,A))
												hi = _applyRewrite419(hi); // !=(/(A,C),rev(A)) => !=(A,/(A,C))
											} else {
												hi = _applyRewrite410(hi); // !=(/(b,rev(A)),A) => !=(A,/(b,A))
												hi = _applyRewrite415(hi); // !=(/(B,rev(A)),A) => !=(A,/(B,A))
												hi = _applyRewrite418(hi); // !=(/(rev(A),C),A) => !=(A,/(A,C))
											}
										}
									}
								}
							} else if ( hi_0 instanceof AggBinaryOp ) {
								hi = _applyRewrite464(hi); // !=(%*%(B,rev(A)),A) => !=(A,%*%(B,A))
								hi = _applyRewrite468(hi); // !=(%*%(rev(A),C),A) => !=(A,%*%(A,C))
							} else {
								if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof ReorgOp ) {
										if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.REV ) {
											if ( hi_1.getInput().size() == 1 ) {
												Hop hi_1_0 = hi_1.getInput(0);
												if ( hi_1_0.getDataType() == Types.DataType.MATRIX ) {
													if ( hi_1_0 instanceof BinaryOp ) {
														if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.MINUS ) {
															hi = _applyRewrite194(hi); // !=(A,rev(-(b,A))) => !=(A,-(b,A))
															hi = _applyRewrite199(hi); // !=(A,rev(-(A,c))) => !=(A,-(A,c))
														} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.PLUS ) {
															hi = _applyRewrite214(hi); // !=(A,rev(+(c,A))) => !=(A,+(A,c))
															hi = _applyRewrite215(hi); // !=(A,rev(+(A,c))) => !=(A,+(A,c))
														} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
															hi = _applyRewrite234(hi); // !=(A,rev(!=(c,A))) => !=(A,!=(A,c))
															hi = _applyRewrite235(hi); // !=(A,rev(!=(A,c))) => !=(A,!=(A,c))
														} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.MULT ) {
															hi = _applyRewrite380(hi); // !=(A,rev(*(c,A))) => !=(A,*(A,c))
															hi = _applyRewrite381(hi); // !=(A,rev(*(A,c))) => !=(A,*(A,c))
														} else if ( (( BinaryOp ) hi_1_0 ).getOp() == Types.OpOp2.DIV ) {
															hi = _applyRewrite414(hi); // !=(A,rev(/(b,A))) => !=(A,/(b,A))
														}
													} else if ( hi_1_0 instanceof AggUnaryOp ) {
														hi = _applyRewrite438(hi); // !=(A,rev(rowSums(A))) => !=(A,rowSums(A))
													} else if ( hi_1_0 instanceof AggBinaryOp ) {
														hi = _applyRewrite467(hi); // !=(A,rev(%*%(A,C))) => !=(A,%*%(A,C))
													}
												}
											}
										} else if ( (( ReorgOp ) hi_1 ).getOp() == Types.ReOrgOp.TRANS ) {
											hi = _applyRewrite431(hi); // !=(A,t(colSums(A))) => !=(A,cast.MATRIX(sum(A)))
										}
									} else if ( hi_1 instanceof BinaryOp ) {
										if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MINUS ) {
											hi = _applyRewrite197(hi); // !=(A,-(b,rev(A))) => !=(A,-(b,A))
											hi = _applyRewrite201(hi); // !=(A,-(rev(A),c)) => !=(A,-(A,c))
											hi = _applyRewrite204(hi); // !=(A,-(B,rev(A))) => !=(A,-(B,A))
											hi = _applyRewrite207(hi); // !=(A,-(rev(A),C)) => !=(A,-(A,C))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.PLUS ) {
											hi = _applyRewrite219(hi); // !=(A,+(rev(A),c)) => !=(A,+(A,c))
											hi = _applyRewrite220(hi); // !=(A,+(c,rev(A))) => !=(A,+(A,c))
											hi = _applyRewrite225(hi); // !=(A,+(rev(A),C)) => !=(A,+(A,C))
											hi = _applyRewrite226(hi); // !=(A,+(C,rev(A))) => !=(A,+(A,C))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.NOTEQUAL ) {
											hi = _applyRewrite230(hi); // !=(A,!=(rev(A),c)) => !=(A,!=(A,c))
											hi = _applyRewrite231(hi); // !=(A,!=(c,rev(A))) => !=(A,!=(A,c))
											hi = _applyRewrite240(hi); // !=(A,!=(rev(A),C)) => !=(A,!=(A,C))
											hi = _applyRewrite241(hi); // !=(A,!=(C,rev(A))) => !=(A,!=(A,C))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MULT ) {
											hi = _applyRewrite376(hi); // !=(A,*(rev(A),c)) => !=(A,*(A,c))
											hi = _applyRewrite377(hi); // !=(A,*(c,rev(A))) => !=(A,*(A,c))
											hi = _applyRewrite386(hi); // !=(A,*(rev(A),C)) => !=(A,*(A,C))
											hi = _applyRewrite387(hi); // !=(A,*(C,rev(A))) => !=(A,*(A,C))
										} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.DIV ) {
											hi = _applyRewrite412(hi); // !=(A,/(b,rev(A))) => !=(A,/(b,A))
											hi = _applyRewrite417(hi); // !=(A,/(B,rev(A))) => !=(A,/(B,A))
											hi = _applyRewrite420(hi); // !=(A,/(rev(A),C)) => !=(A,/(A,C))
										}
									} else if ( hi_1 instanceof AggUnaryOp ) {
										hi = _applyRewrite439(hi); // !=(A,rowSums(rev(A))) => !=(A,rowSums(A))
										hi = _applyRewrite440(hi); // !=(A,colSums(rev(A))) => !=(A,colSums(A))
									} else if ( hi_1 instanceof AggBinaryOp ) {
										hi = _applyRewrite465(hi); // !=(A,%*%(B,rev(A))) => !=(A,%*%(B,A))
										hi = _applyRewrite469(hi); // !=(A,%*%(rev(A),C)) => !=(A,%*%(A,C))
									}
								}
							}
						}
					}
				}
			} else if ( hi instanceof AggUnaryOp ) {
				if ( (( AggUnaryOp ) hi ).getOp() == Types.AggOp.SUM ) {
					if ( hi.getInput().size() == 1 ) {
						Hop hi_0 = hi.getInput(0);
						if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite21(hi); // colSums(*(a,B)) => *(a,colSums(B))
											hi = _applyRewrite23(hi); // rowSums(*(a,B)) => *(a,rowSums(B))
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_0_0 instanceof BinaryOp ) {
												hi = _applyRewrite162(hi); // colSums(*($1:/(a,C),B)) => *(a,colSums($1:/(B,C)))
												hi = _applyRewrite164(hi); // rowSums(*($1:/(a,C),B)) => *(a,rowSums($1:/(B,C)))
											} else {
												hi = _applyRewrite22(hi); // colSums(*(B,a)) => *(a,colSums(B))
												hi = _applyRewrite24(hi); // rowSums(*(B,a)) => *(a,rowSums(B))
												hi = _applyRewrite163(hi); // colSums(*(B,$1:/(a,C))) => *(a,colSums($1:/(B,C)))
												hi = _applyRewrite165(hi); // rowSums(*(B,$1:/(a,C))) => *(a,rowSums($1:/(B,C)))
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											if ( hi_0_1.getDataType() == Types.DataType.MATRIX ) {
												if ( hi_0_1 instanceof ReorgOp ) {
													hi = _applyRewrite358(hi); // colSums(-(a,$1:t(B))) => t(rowSums($1:-(a,B)))
													hi = _applyRewrite360(hi); // rowSums(-(a,$1:t(B))) => t(colSums($1:-(a,B)))
												} else {
													hi = _applyRewrite61(hi); // colSums(-(0.0,B)) => -(0.0,colSums(B))
													hi = _applyRewrite62(hi); // rowSums(-(0.0,B)) => -(0.0,rowSums(B))
												}
											}
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite357(hi); // colSums(-($1:t(A),b)) => t(rowSums($1:-(A,b)))
											hi = _applyRewrite359(hi); // rowSums(-($1:t(A),b)) => t(colSums($1:-(A,b)))
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.PLUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite366(hi); // colSums(+(b,$1:t(A))) => t(rowSums($1:+(A,b)))
											hi = _applyRewrite368(hi); // rowSums(+(b,$1:t(A))) => t(colSums($1:+(A,b)))
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite365(hi); // colSums(+($1:t(A),b)) => t(rowSums($1:+(A,b)))
											hi = _applyRewrite367(hi); // rowSums(+($1:t(A),b)) => t(colSums($1:+(A,b)))
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite160(hi); // colSums(/($1:*(a,B),C)) => *(a,colSums($1:/(B,C)))
											hi = _applyRewrite161(hi); // colSums(/($1:*(B,a),C)) => *(a,colSums($1:/(B,C)))
											hi = _applyRewrite166(hi); // rowSums(/($1:*(a,B),C)) => *(a,rowSums($1:/(B,C)))
											hi = _applyRewrite167(hi); // rowSums(/($1:*(B,a),C)) => *(a,rowSums($1:/(B,C)))
										} else if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite428(hi); // colSums(/(a,t(B))) => t(rowSums($1:/(a,B)))
											hi = _applyRewrite429(hi); // rowSums(/(a,t(B))) => t(colSums($1:/(a,B)))
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									hi = _applyRewrite361(hi); // colSums(!=(t(A),b)) => t(rowSums($1:!=(A,b)))
									hi = _applyRewrite362(hi); // colSums(!=(b,t(A))) => t(rowSums($1:!=(A,b)))
									hi = _applyRewrite363(hi); // rowSums(!=(t(A),b)) => t(colSums($1:!=(A,b)))
									hi = _applyRewrite364(hi); // rowSums(!=(b,t(A))) => t(colSums($1:!=(A,b)))
								}
							} else if ( hi_0 instanceof ReorgOp ) {
								hi = _applyRewrite114(hi); // rowSums(rev($1:*(a,B))) => *(a,rowSums($1:rev(B)))
								hi = _applyRewrite115(hi); // rowSums(rev($1:*(B,a))) => *(a,rowSums($1:rev(B)))
								hi = _applyRewrite116(hi); // colSums(rev($1:*(a,B))) => *(a,colSums($1:rev(B)))
								hi = _applyRewrite117(hi); // colSums(rev($1:*(B,a))) => *(a,colSums($1:rev(B)))
							}
						}
					}
				}
			} else if ( hi instanceof ReorgOp ) {
				if ( (( ReorgOp ) hi ).getOp() == Types.ReOrgOp.REV ) {
					if ( hi.getInput().size() == 1 ) {
						Hop hi_0 = hi.getInput(0);
						if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof UnaryOp ) {
								hi = _applyRewrite31(hi); // rev(cast.MATRIX(a)) => cast.MATRIX(a)
							} else if ( hi_0 instanceof AggUnaryOp ) {
								hi = _applyRewrite76(hi); // rev(colSums(A)) => colSums(A)
							} else if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite98(hi); // rev(-(a,$1:rev(B))) => -(a,B)
											hi = _applyRewrite485(hi); // rev(-(a,$1:colSums(B))) => -(a,colSums(B))
										} else if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite100(hi); // rev(-($1:rev(A),b)) => -(A,b)
											hi = _applyRewrite187(hi); // rev(-($1:rev(A),B)) => -(A,rev(B))
											hi = _applyRewrite188(hi); // rev(-(A,$1:rev(B))) => -(rev(A),B)
											hi = _applyRewrite484(hi); // rev(-($1:colSums(A),b)) => -(colSums(A),b)
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite102(hi); // rev(!=(rev(A),b)) => !=(A,b)
											hi = _applyRewrite208(hi); // rev(!=(rev(A),B)) => !=(A,rev(B))
											hi = _applyRewrite209(hi); // rev(!=(B,rev(A))) => !=(A,rev(B))
											hi = _applyRewrite432(hi); // rev(!=(cast.MATRIX(a),b)) => !=(a,cast.MATRIX(b))
											hi = _applyRewrite486(hi); // rev(!=(colSums(B),a)) => !=(a,colSums(B))
										} else if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite103(hi); // rev(!=(b,rev(A))) => !=(A,b)
											hi = _applyRewrite433(hi); // rev(!=(a,cast.MATRIX(b))) => !=(a,cast.MATRIX(b))
											hi = _applyRewrite487(hi); // rev(!=(a,colSums(B))) => !=(a,colSums(B))
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.PLUS ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite106(hi); // rev(+($1:rev(A),b)) => +(A,b)
											hi = _applyRewrite242(hi); // rev(+($1:rev(A),B)) => +(A,rev(B))
											hi = _applyRewrite243(hi); // rev(+(B,$1:rev(A))) => +(A,rev(B))
											hi = _applyRewrite489(hi); // rev(+($1:colSums(B),a)) => +(a,colSums(B))
										} else if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite107(hi); // rev(+(b,$1:rev(A))) => +(A,b)
											hi = _applyRewrite490(hi); // rev(+(a,$1:colSums(B))) => +(a,colSums(B))
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_0_0.getDataType() == Types.DataType.MATRIX ) {
											hi = _applyRewrite110(hi); // rev(*($1:rev(A),b)) => *(A,b)
											hi = _applyRewrite388(hi); // rev(*($1:rev(A),B)) => *(A,rev(B))
											hi = _applyRewrite389(hi); // rev(*(B,$1:rev(A))) => *(A,rev(B))
											hi = _applyRewrite491(hi); // rev(*($1:colSums(B),a)) => *(a,colSums(B))
										} else if ( hi_0_0.getDataType() == Types.DataType.SCALAR ) {
											hi = _applyRewrite111(hi); // rev(*(b,$1:rev(A))) => *(A,b)
											hi = _applyRewrite492(hi); // rev(*(a,$1:colSums(B))) => *(a,colSums(B))
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									hi = _applyRewrite118(hi); // rev(/(a,rev(B))) => /(a,B)
									hi = _applyRewrite405(hi); // rev(/($1:rev(A),B)) => /(A,rev(B))
									hi = _applyRewrite406(hi); // rev(/(A,rev(B))) => /(rev(A),B)
									hi = _applyRewrite493(hi); // rev(/(a,colSums(B))) => /(a,colSums(B))
								}
							} else if ( hi_0 instanceof AggBinaryOp ) {
								hi = _applyRewrite470(hi); // rev(%*%($1:!=(b,A),A)) => %*%(!=(A,b),A)
								hi = _applyRewrite471(hi); // rev(%*%($1:!=(A,b),A)) => %*%(!=(A,b),A)
								hi = _applyRewrite498(hi); // rev(%*%($1:colSums(A),B)) => %*%(colSums(A),B)
							} else if ( hi_0 instanceof ReorgOp ) {
								hi = _applyRewrite488(hi); // rev(t($1:rowSums(A))) => t(rowSums(A))
							}
						}
					}
				} else if ( (( ReorgOp ) hi ).getOp() == Types.ReOrgOp.TRANS ) {
					if ( hi.getInput().size() == 1 ) {
						Hop hi_0 = hi.getInput(0);
						if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MINUS ) {
									hi = _applyRewrite99(hi); // t(-(a,$1:t(B))) => -(a,B)
									hi = _applyRewrite101(hi); // t(-($1:t(A),b)) => -(A,b)
									hi = _applyRewrite189(hi); // t(-($1:t(A),B)) => -(A,t(B))
									hi = _applyRewrite190(hi); // t(-(A,$1:t(B))) => -(t(A),B)
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									hi = _applyRewrite104(hi); // t(!=(t(A),b)) => !=(A,b)
									hi = _applyRewrite105(hi); // t(!=(b,t(A))) => !=(A,b)
									hi = _applyRewrite210(hi); // t(!=(t(A),B)) => !=(A,t(B))
									hi = _applyRewrite211(hi); // t(!=(B,t(A))) => !=(A,t(B))
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.PLUS ) {
									hi = _applyRewrite108(hi); // t(+($1:t(A),b)) => +(A,b)
									hi = _applyRewrite109(hi); // t(+(b,$1:t(A))) => +(A,b)
									hi = _applyRewrite244(hi); // t(+($1:t(A),B)) => +(A,t(B))
									hi = _applyRewrite245(hi); // t(+(B,$1:t(A))) => +(A,t(B))
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									hi = _applyRewrite112(hi); // t(*($1:t(A),b)) => *(A,b)
									hi = _applyRewrite113(hi); // t(*(b,$1:t(A))) => *(A,b)
									hi = _applyRewrite390(hi); // t(*($1:t(A),B)) => *(A,t(B))
									hi = _applyRewrite391(hi); // t(*(B,$1:t(A))) => *(A,t(B))
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									hi = _applyRewrite119(hi); // t(/(a,t(B))) => /(a,B)
									hi = _applyRewrite407(hi); // t(/($1:t(A),B)) => /(A,t(B))
									hi = _applyRewrite408(hi); // t(/(A,t(B))) => /(t(A),B)
								}
							} else if ( hi_0 instanceof AggBinaryOp ) {
								hi = _applyRewrite461(hi); // t(%*%($1:t(B),A)) => %*%(t(A),B)
								hi = _applyRewrite462(hi); // t(%*%(B,$1:t(A))) => %*%(A,t(B))
							}
						}
					}
				}
			} else if ( hi instanceof AggBinaryOp ) {
				if ( HopRewriteUtils.isMatrixMultiply(hi) ) {
					if ( hi.getInput().size() == 2 ) {
						Hop hi_0 = hi.getInput(0);
						Hop hi_1 = hi.getInput(1);
						if ( hi_0.getDataType() == Types.DataType.MATRIX ) {
							if ( hi_0 instanceof AggUnaryOp ) {
								hi = _applyRewrite156(hi); // %*%(colSums(B),*(a,C)) => *(a,%*%($1:colSums(B),C))
								hi = _applyRewrite157(hi); // %*%(colSums(B),*(C,a)) => *(a,%*%($1:colSums(B),C))
							} else if ( hi_0 instanceof BinaryOp ) {
								if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.MULT ) {
									if ( hi_0.getInput().size() == 2 ) {
										Hop hi_0_0 = hi_0.getInput(0);
										Hop hi_0_1 = hi_0.getInput(1);
										if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
											if ( hi_1 instanceof AggUnaryOp ) {
												hi = _applyRewrite158(hi); // %*%(*(a,B),rowSums(C)) => *(a,%*%(B,$1:rowSums(C)))
												hi = _applyRewrite159(hi); // %*%(*(B,a),rowSums(C)) => *(a,%*%(B,$1:rowSums(C)))
											} else if ( hi_1 instanceof BinaryOp ) {
												if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.MULT ) {
													hi = _applyRewrite443(hi); // %*%(*(a,C),*(b,D)) => *(*(a,b),%*%(C,D))
													hi = _applyRewrite444(hi); // %*%(*(a,C),*(D,b)) => *(*(a,b),%*%(C,D))
													hi = _applyRewrite445(hi); // %*%(*(C,a),*(b,D)) => *(*(a,b),%*%(C,D))
													hi = _applyRewrite446(hi); // %*%(*(C,a),*(D,b)) => *(*(a,b),%*%(C,D))
												} else if ( (( BinaryOp ) hi_1 ).getOp() == Types.OpOp2.DIV ) {
													hi = _applyRewrite457(hi); // %*%(*(b,A),/(c,D)) => %*%(A,/(*(b,c),D))
													hi = _applyRewrite458(hi); // %*%(*(A,b),/(c,D)) => %*%(A,/(*(b,c),D))
												}
											}
										}
									}
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.DIV ) {
									hi = _applyRewrite453(hi); // %*%(/(a,C),*(b,D)) => %*%(/(*(a,b),C),D)
									hi = _applyRewrite454(hi); // %*%(/(a,C),*(D,b)) => %*%(/(*(a,b),C),D)
								} else if ( (( BinaryOp ) hi_0 ).getOp() == Types.OpOp2.NOTEQUAL ) {
									hi = _applyRewrite472(hi); // %*%(!=(rev(A),b),A) => %*%(!=(A,b),A)
									hi = _applyRewrite473(hi); // %*%(!=(b,rev(A)),A) => %*%(!=(A,b),A)
									hi = _applyRewrite476(hi); // %*%(!=(rev(A),B),A) => %*%(!=(A,B),A)
									hi = _applyRewrite477(hi); // %*%(!=(B,rev(A)),A) => %*%(!=(A,B),A)
								}
							} else if ( hi_0 instanceof ReorgOp ) {
								hi = _applyRewrite463(hi); // %*%(t(B),t(A)) => t(%*%(A,B))
								hi = _applyRewrite474(hi); // %*%(rev($1:!=(b,A)),A) => %*%(!=(A,b),A)
								hi = _applyRewrite475(hi); // %*%(rev($1:!=(A,b)),A) => %*%(!=(A,b),A)
							} else {
								if ( hi_1.getDataType() == Types.DataType.MATRIX ) {
									if ( hi_1 instanceof BinaryOp ) {
										hi = _applyRewrite478(hi); // %*%(A,!=(rev(A),c)) => %*%(A,!=(A,c))
										hi = _applyRewrite479(hi); // %*%(A,!=(c,rev(A))) => %*%(A,!=(A,c))
										hi = _applyRewrite482(hi); // %*%(A,!=(rev(A),C)) => %*%(A,!=(A,C))
										hi = _applyRewrite483(hi); // %*%(A,!=(C,rev(A))) => %*%(A,!=(A,C))
									} else if ( hi_1 instanceof ReorgOp ) {
										hi = _applyRewrite480(hi); // %*%(A,rev($1:!=(c,A))) => %*%(A,!=(A,c))
										hi = _applyRewrite481(hi); // %*%(A,rev($1:!=(A,c))) => %*%(A,!=(A,c))
									}
								}
							}
						}
					}
				}
			}
		}
		return hi;
	}

	// Implementation of the rule *(1.0,a) => a
	private static Hop _applyRewrite0(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(1.0,a) => a");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return hi_1;
	}

	// Implementation of the rule *(a,1.0) => a
	private static Hop _applyRewrite1(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( !(hi_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1 = (LiteralOp) hi_1;

		if ( l_hi_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1.getDoubleValue() != 1.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,1.0) => a");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_0);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return hi_0;
	}

	// Implementation of the rule /(a,1.0) => a
	private static Hop _applyRewrite2(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( !(hi_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1 = (LiteralOp) hi_1;

		if ( l_hi_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1.getDoubleValue() != 1.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(a,1.0) => a");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_0);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return hi_0;
	}

	// Implementation of the rule +(0.0,a) => a
	private static Hop _applyRewrite3(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(0.0,a) => a");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return hi_1;
	}

	// Implementation of the rule +(a,0.0) => a
	private static Hop _applyRewrite4(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( !(hi_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1 = (LiteralOp) hi_1;

		if ( l_hi_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,0.0) => a");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_0);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return hi_0;
	}

	// Implementation of the rule +(0.0,A) => A
	private static Hop _applyRewrite5(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(0.0,A) => A");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return hi_1;
	}

	// Implementation of the rule +(A,0.0) => A
	private static Hop _applyRewrite6(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( !(hi_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1 = (LiteralOp) hi_1;

		if ( l_hi_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,0.0) => A");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_0);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return hi_0;
	}

	// Implementation of the rule *(0.0,a) => 0.0
	private static Hop _applyRewrite7(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(0.0,a) => 0.0");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_0);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return hi_0;
	}

	// Implementation of the rule *(a,0.0) => 0.0
	private static Hop _applyRewrite8(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( !(hi_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1 = (LiteralOp) hi_1;

		if ( l_hi_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,0.0) => 0.0");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return hi_1;
	}

	// Implementation of the rule /(0.0,a) => 0.0
	private static Hop _applyRewrite9(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(0.0,a) => 0.0");

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, hi_0);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return hi_0;
	}

	// Implementation of the rule /(0.0,A) => const(A,0.0)
	private static Hop _applyRewrite10(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(0.0,A) => const(A,0.0)");
		DataGenOp v1 = ((DataGenOp) HopRewriteUtils.createDataGenOp(HopRewriteUtils.createUnary(hi_1, Types.OpOp1.NROW),HopRewriteUtils.createUnary(hi_1, Types.OpOp1.NCOL),0.0D));

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);

		return v1;
	}

	// Implementation of the rule *(0.0,A) => const(A,0.0)
	private static Hop _applyRewrite11(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(0.0,A) => const(A,0.0)");
		DataGenOp v1 = ((DataGenOp) HopRewriteUtils.createDataGenOp(HopRewriteUtils.createUnary(hi_1, Types.OpOp1.NROW),HopRewriteUtils.createUnary(hi_1, Types.OpOp1.NCOL),0.0D));

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);

		return v1;
	}

	// Implementation of the rule *(A,0.0) => const(A,0.0)
	private static Hop _applyRewrite12(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( !(hi_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1 = (LiteralOp) hi_1;

		if ( l_hi_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,0.0) => const(A,0.0)");
		DataGenOp v1 = ((DataGenOp) HopRewriteUtils.createDataGenOp(HopRewriteUtils.createUnary(hi_0, Types.OpOp1.NROW),HopRewriteUtils.createUnary(hi_0, Types.OpOp1.NCOL),0.0D));

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);

		return v1;
	}

	// Implementation of the rule /(A,c) => *(A,/(1.0,c))
	private static Hop _applyRewrite13(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,c) => *(A,/(1.0,c))");
		LiteralOp l1 = new LiteralOp( 1.0 );
		BinaryOp v2 = HopRewriteUtils.createBinary(l1, hi_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);

		return v3;
	}

	// Implementation of the rule trace(*(a,B)) => *(a,trace(B))
	private static Hop _applyRewrite16(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(*(a,B)) => *(a,trace(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule trace(*(B,a)) => *(a,trace(B))
	private static Hop _applyRewrite17(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(*(B,a)) => *(a,trace(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule colSums(*(a,B)) => *(a,colSums(B))
	private static Hop _applyRewrite21(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1.getDim2() == -1 || hi_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_1.getNnz()) + hi_0_1.getNnz() + 20020.0);
		double costTo = (hi_0_1.getNnz() + (2.0 * (1.0 * hi_0_1.getDim2())) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(*(a,B)) => *(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule colSums(*(B,a)) => *(a,colSums(B))
	private static Hop _applyRewrite22(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0.getNnz()) + hi_0_0.getNnz() + 20020.0);
		double costTo = (hi_0_0.getNnz() + (2.0 * (1.0 * hi_0_0.getDim2())) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(*(B,a)) => *(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule rowSums(*(a,B)) => *(a,rowSums(B))
	private static Hop _applyRewrite23(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1.getNnz() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_1.getNnz()) + hi_0_1.getNnz() + 20020.0);
		double costTo = (hi_0_1.getNnz() + (2.0 * (hi_0_1.getDim1() * 1.0)) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(*(a,B)) => *(a,rowSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule rowSums(*(B,a)) => *(a,rowSums(B))
	private static Hop _applyRewrite24(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0.getNnz()) + hi_0_0.getNnz() + 20020.0);
		double costTo = (hi_0_0.getNnz() + (2.0 * (hi_0_0.getDim1() * 1.0)) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(*(B,a)) => *(a,rowSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule *(cast.MATRIX(0.0),a) => cast.MATRIX(0.0)
	private static Hop _applyRewrite25(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(cast.MATRIX(0.0),a) => cast.MATRIX(0.0)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_0_0, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v1;
	}

	// Implementation of the rule *(a,cast.MATRIX(0.0)) => cast.MATRIX(0.0)
	private static Hop _applyRewrite26(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,cast.MATRIX(0.0)) => cast.MATRIX(0.0)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_1_0, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v1;
	}

	// Implementation of the rule *(cast.MATRIX(1.0),a) => cast.MATRIX(a)
	private static Hop _applyRewrite27(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(cast.MATRIX(1.0),a) => cast.MATRIX(a)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule *(a,cast.MATRIX(1.0)) => cast.MATRIX(a)
	private static Hop _applyRewrite28(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 1.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,cast.MATRIX(1.0)) => cast.MATRIX(a)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_0, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule +(cast.MATRIX(0.0),a) => cast.MATRIX(a)
	private static Hop _applyRewrite29(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(cast.MATRIX(0.0),a) => cast.MATRIX(a)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule +(a,cast.MATRIX(0.0)) => cast.MATRIX(a)
	private static Hop _applyRewrite30(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,cast.MATRIX(0.0)) => cast.MATRIX(a)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_0, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule rev(cast.MATRIX(a)) => cast.MATRIX(a)
	private static Hop _applyRewrite31(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(cast.MATRIX(a)) => cast.MATRIX(a)");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_0_0, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v1;
	}

	// Implementation of the rule *(/(1.0,B),a) => /(a,B)
	private static Hop _applyRewrite32(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/(1.0,B),a) => /(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule *(a,/(1.0,B)) => /(a,B)
	private static Hop _applyRewrite33(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,/(1.0,B)) => /(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule *(/(1.0,B),A) => /(A,B)
	private static Hop _applyRewrite34(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/(1.0,B),A) => /(A,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule *(A,/(1.0,B)) => /(A,B)
	private static Hop _applyRewrite35(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,/(1.0,B)) => /(A,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule *(/(a,C),b) => /(*(a,b),C)
	private static Hop _applyRewrite36(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/(a,C),b) => /(*(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule *(a,/(b,C)) => /(*(a,b),C)
	private static Hop _applyRewrite37(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,/(b,C)) => /(*(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule sum(-(0.0,B)) => -(0.0,sum(B))
	private static Hop _applyRewrite38(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(-(0.0,B)) => -(0.0,sum(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1, Types.AggOp.SUM, Types.Direction.RowCol);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(0.0,-(B,a)) => -(a,B)
	private static Hop _applyRewrite42(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(0.0,-(B,a)) => -(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v1;
	}

	// Implementation of the rule +(-(0.0,B),a) => -(a,B)
	private static Hop _applyRewrite43(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(0.0,B),a) => -(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule +(a,-(0.0,B)) => -(a,B)
	private static Hop _applyRewrite44(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,-(0.0,B)) => -(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule -(0.0,-(b,A)) => -(A,b)
	private static Hop _applyRewrite45(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(0.0,-(b,A)) => -(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v1;
	}

	// Implementation of the rule -(0.0,-(B,A)) => -(A,B)
	private static Hop _applyRewrite46(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(0.0,-(B,A)) => -(A,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v1;
	}

	// Implementation of the rule +(-(0.0,B),A) => -(A,B)
	private static Hop _applyRewrite47(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(0.0,B),A) => -(A,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule +(A,-(0.0,B)) => -(A,B)
	private static Hop _applyRewrite48(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,-(0.0,B)) => -(A,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule -(-(A,b),c) => -(A,+(b,c))
	private static Hop _applyRewrite49(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,b),c) => -(A,+(b,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(a,+(b,C)) => -(-(a,b),C)
	private static Hop _applyRewrite50(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,+(b,C)) => -(-(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(a,+(C,b)) => -(-(a,b),C)
	private static Hop _applyRewrite51(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,+(C,b)) => -(-(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(-(a,C),b) => -(-(a,b),C)
	private static Hop _applyRewrite52(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(a,C),b) => -(-(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(a,-(C,b)) => -(+(a,b),C)
	private static Hop _applyRewrite53(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,-(C,b)) => -(+(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(-(a,C),b) => -(+(a,b),C)
	private static Hop _applyRewrite54(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(a,C),b) => -(+(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule +(a,-(b,C)) => -(+(a,b),C)
	private static Hop _applyRewrite55(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,-(b,C)) => -(+(a,b),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(+(b,A),c) => +(A,-(b,c))
	private static Hop _applyRewrite56(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(b,A),c) => +(A,-(b,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(+(A,b),c) => +(A,-(b,c))
	private static Hop _applyRewrite57(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(A,b),c) => +(A,-(b,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(b,-(c,A)) => +(A,-(b,c))
	private static Hop _applyRewrite58(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-(c,A)) => +(A,-(b,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(-(A,c),b) => +(A,-(b,c))
	private static Hop _applyRewrite59(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(A,c),b) => +(A,-(b,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule +(b,-(A,c)) => +(A,-(b,c))
	private static Hop _applyRewrite60(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-(A,c)) => +(A,-(b,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule colSums(-(0.0,B)) => -(0.0,colSums(B))
	private static Hop _applyRewrite61(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1.getDim2() == -1 || hi_0_1.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1.getNnz() + hi_0_1.getNnz() + 20020.0);
		double costTo = (hi_0_1.getNnz() + (1.0 * hi_0_1.getDim2()) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(-(0.0,B)) => -(0.0,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule rowSums(-(0.0,B)) => -(0.0,rowSums(B))
	private static Hop _applyRewrite62(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1.getNnz() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = (hi_0_1.getNnz() + hi_0_1.getNnz() + 20020.0);
		double costTo = (hi_0_1.getNnz() + (hi_0_1.getDim1() * 1.0) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(-(0.0,B)) => -(0.0,rowSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(cast.MATRIX(a),b) => cast.MATRIX(-(a,b))
	private static Hop _applyRewrite69(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(cast.MATRIX(a),b) => cast.MATRIX(-(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.MINUS);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule -(a,cast.MATRIX(b)) => cast.MATRIX(-(a,b))
	private static Hop _applyRewrite70(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,cast.MATRIX(b)) => cast.MATRIX(-(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MINUS);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(cast.MATRIX(a),b) => cast.MATRIX(+(a,b))
	private static Hop _applyRewrite71(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(cast.MATRIX(a),b) => cast.MATRIX(+(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.PLUS);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule +(a,cast.MATRIX(b)) => cast.MATRIX(+(a,b))
	private static Hop _applyRewrite72(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,cast.MATRIX(b)) => cast.MATRIX(+(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.PLUS);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule *(cast.MATRIX(a),b) => cast.MATRIX(*(a,b))
	private static Hop _applyRewrite73(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0 = (UnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(cast.MATRIX(a),b) => cast.MATRIX(*(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.MULT);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v2;
	}

	// Implementation of the rule *(a,cast.MATRIX(b)) => cast.MATRIX(*(a,b))
	private static Hop _applyRewrite74(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,cast.MATRIX(b)) => cast.MATRIX(*(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MULT);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule /(a,cast.MATRIX(b)) => cast.MATRIX(/(a,b))
	private static Hop _applyRewrite75(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_1 = (UnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(a,cast.MATRIX(b)) => cast.MATRIX(/(a,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.DIV);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule rev(colSums(A)) => colSums(A)
	private static Hop _applyRewrite76(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0 = (AggUnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.AggOp.SUM || !c_hi_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(colSums(A)) => colSums(A)");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.SUM, Types.Direction.Col);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);

		return v1;
	}

	// Implementation of the rule *(/(1.0,b),a) => /(a,b)
	private static Hop _applyRewrite77(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/(1.0,b),a) => /(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule *(a,/(1.0,b)) => /(a,b)
	private static Hop _applyRewrite78(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 1.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,/(1.0,b)) => /(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule -(0.0,-(b,a)) => -(a,b)
	private static Hop _applyRewrite79(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(0.0,-(b,a)) => -(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v1;
	}

	// Implementation of the rule -(a,-(b,0.0)) => -(a,b)
	private static Hop _applyRewrite80(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( !(hi_1_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_1 = (LiteralOp) hi_1_1;

		if ( l_hi_1_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,-(b,0.0)) => -(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v1;
	}

	// Implementation of the rule +(-(0.0,b),a) => -(a,b)
	private static Hop _applyRewrite81(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(0.0,b),a) => -(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule +(a,-(0.0,b)) => -(a,b)
	private static Hop _applyRewrite82(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,-(0.0,b)) => -(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule *(-(a,0.0),b) => *(a,b)
	private static Hop _applyRewrite83(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( !(hi_0_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_1 = (LiteralOp) hi_0_1;

		if ( l_hi_0_1.getDataType() != Types.DataType.SCALAR|| !l_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_1.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(-(a,0.0),b) => *(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule *(a,-(b,0.0)) => *(a,b)
	private static Hop _applyRewrite84(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( !(hi_1_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_1 = (LiteralOp) hi_1_1;

		if ( l_hi_1_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,-(b,0.0)) => *(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v1;
	}

	// Implementation of the rule /(-(a,0.0),b) => /(a,b)
	private static Hop _applyRewrite85(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( !(hi_0_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_1 = (LiteralOp) hi_0_1;

		if ( l_hi_0_1.getDataType() != Types.DataType.SCALAR|| !l_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_1.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(-(a,0.0),b) => /(a,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule -(0.0,*(b,A)) => -*(const(A,0.0),b,A)
	private static Hop _applyRewrite86(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(0.0,*(b,A)) => -*(const(A,0.0),b,A)");
		DataGenOp v1 = ((DataGenOp) HopRewriteUtils.createDataGenOp(HopRewriteUtils.createUnary(hi_1_1, Types.OpOp1.NROW),HopRewriteUtils.createUnary(hi_1_1, Types.OpOp1.NCOL),0.0D));
		TernaryOp v2 = HopRewriteUtils.createTernary(v1, hi_1_0, hi_1_1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(0.0,*(A,b)) => -*(const(A,0.0),b,A)
	private static Hop _applyRewrite87(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( !(hi_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0 = (LiteralOp) hi_0;

		if ( l_hi_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(0.0,*(A,b)) => -*(const(A,0.0),b,A)");
		DataGenOp v1 = ((DataGenOp) HopRewriteUtils.createDataGenOp(HopRewriteUtils.createUnary(hi_1_0, Types.OpOp1.NROW),HopRewriteUtils.createUnary(hi_1_0, Types.OpOp1.NCOL),0.0D));
		TernaryOp v2 = HopRewriteUtils.createTernary(v1, hi_1_1, hi_1_0,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(A,-(b,0.0)) => -(A,b)
	private static Hop _applyRewrite88(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( !(hi_1_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_1 = (LiteralOp) hi_1_1;

		if ( l_hi_1_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,-(b,0.0)) => -(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v1;
	}

	// Implementation of the rule +(-(0.0,b),A) => -(A,b)
	private static Hop _applyRewrite89(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( !(hi_0_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_0 = (LiteralOp) hi_0_0;

		if ( l_hi_0_0.getDataType() != Types.DataType.SCALAR|| !l_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(0.0,b),A) => -(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule +(A,-(0.0,b)) => -(A,b)
	private static Hop _applyRewrite90(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( !(hi_1_0 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_0 = (LiteralOp) hi_1_0;

		if ( l_hi_1_0.getDataType() != Types.DataType.SCALAR|| !l_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_0.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,-(0.0,b)) => -(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v1;
	}

	// Implementation of the rule *(-(b,0.0),A) => *(A,b)
	private static Hop _applyRewrite91(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( !(hi_0_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_1 = (LiteralOp) hi_0_1;

		if ( l_hi_0_1.getDataType() != Types.DataType.SCALAR|| !l_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_1.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(-(b,0.0),A) => *(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_0, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule *(A,-(b,0.0)) => *(A,b)
	private static Hop _applyRewrite92(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( !(hi_1_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_1_1 = (LiteralOp) hi_1_1;

		if ( l_hi_1_1.getDataType() != Types.DataType.SCALAR|| !l_hi_1_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_1_1.getDoubleValue() != 0.0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,-(b,0.0)) => *(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v1;
	}

	// Implementation of the rule /(-(a,0.0),B) => /(a,B)
	private static Hop _applyRewrite93(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( !(hi_0_1 instanceof LiteralOp) )
			return hi;

		LiteralOp l_hi_0_1 = (LiteralOp) hi_0_1;

		if ( l_hi_0_1.getDataType() != Types.DataType.SCALAR|| !l_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( l_hi_0_1.getDoubleValue() != 0.0 )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(-(a,0.0),B) => /(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule +(%*%(B,C),%*%(A,C)) => %*%(+(A,B),C)
	private static Hop _applyRewrite94(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_0_1 != hi_1_1 )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_0.getDim1() == -1 || hi_0_1.getDim2() == -1 || hi_0_1.getNnz() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 )
			return hi;


		double costFrom = ((Math.min(hi_0_0.getNnz(), hi_0_1.getNnz()) * hi_0_0.getDim2() * 3.0) + (Math.min(hi_1_0.getNnz(), hi_0_1.getNnz()) * hi_0_0.getDim2() * 3.0) + ((Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0.getDim1() * hi_0_1.getDim2()) + (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_1_0.getDim1() * hi_0_1.getDim2())) + 30030.0);
		double costTo = ((hi_1_0.getNnz() + hi_0_0.getNnz()) + (Math.min(Math.min((hi_1_0.getNnz() + hi_0_0.getNnz()), (hi_1_0.getDim1() * hi_1_0.getDim2())), hi_0_1.getNnz()) * hi_0_0.getDim2() * 3.0) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(%*%(B,C),%*%(A,C)) => %*%(+(A,B),C)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0_0, Types.OpOp2.PLUS);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(%*%(A,C),%*%(A,B)) => %*%(A,+(B,C))
	private static Hop _applyRewrite95(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_1.getDim2() == -1 || hi_1_1.getDim2() == -1 || hi_0_1.getNnz() == -1 || hi_0_0.getNnz() == -1 || hi_1_1.getDim1() == -1 || hi_0_1.getDim1() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((Math.min(hi_0_0.getNnz(), hi_0_1.getNnz()) * hi_0_1.getDim1() * 3.0) + (Math.min(hi_0_0.getNnz(), hi_1_1.getNnz()) * hi_0_1.getDim1() * 3.0) + ((Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0.getDim1() * hi_0_1.getDim2()) + (Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_0_0.getDim1() * hi_1_1.getDim2())) + 30030.0);
		double costTo = ((hi_1_1.getNnz() + hi_0_1.getNnz()) + (Math.min(hi_0_0.getNnz(), Math.min((hi_1_1.getNnz() + hi_0_1.getNnz()), (hi_1_1.getDim1() * hi_1_1.getDim2()))) * hi_0_1.getDim1() * 3.0) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(%*%(A,C),%*%(A,B)) => %*%(A,+(B,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_0_1, Types.OpOp2.PLUS);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule trace(+($1:t(A),A)) => +(trace(A),trace(A))
	private static Hop _applyRewrite96(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_0_0 != hi_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+($1:t(A),A)) => +(trace(A),trace(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(+(A,$1:t(A))) => +(trace(A),trace(A))
	private static Hop _applyRewrite97(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_0 != hi_0_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+(A,$1:t(A))) => +(trace(A),trace(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rev(-(a,$1:rev(B))) => -(a,B)
	private static Hop _applyRewrite98(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(-(a,$1:rev(B))) => -(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule t(-(a,$1:t(B))) => -(a,B)
	private static Hop _applyRewrite99(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(-(a,$1:t(B))) => -(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule rev(-($1:rev(A),b)) => -(A,b)
	private static Hop _applyRewrite100(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(-($1:rev(A),b)) => -(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule t(-($1:t(A),b)) => -(A,b)
	private static Hop _applyRewrite101(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(-($1:t(A),b)) => -(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule rev(!=(rev(A),b)) => !=(A,b)
	private static Hop _applyRewrite102(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(rev(A),b)) => !=(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule rev(!=(b,rev(A))) => !=(A,b)
	private static Hop _applyRewrite103(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(b,rev(A))) => !=(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule t(!=(t(A),b)) => !=(A,b)
	private static Hop _applyRewrite104(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(!=(t(A),b)) => !=(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule t(!=(b,t(A))) => !=(A,b)
	private static Hop _applyRewrite105(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(!=(b,t(A))) => !=(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule rev(+($1:rev(A),b)) => +(A,b)
	private static Hop _applyRewrite106(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(+($1:rev(A),b)) => +(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule rev(+(b,$1:rev(A))) => +(A,b)
	private static Hop _applyRewrite107(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(+(b,$1:rev(A))) => +(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule t(+($1:t(A),b)) => +(A,b)
	private static Hop _applyRewrite108(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(+($1:t(A),b)) => +(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule t(+(b,$1:t(A))) => +(A,b)
	private static Hop _applyRewrite109(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(+(b,$1:t(A))) => +(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule rev(*($1:rev(A),b)) => *(A,b)
	private static Hop _applyRewrite110(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(*($1:rev(A),b)) => *(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule rev(*(b,$1:rev(A))) => *(A,b)
	private static Hop _applyRewrite111(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(*(b,$1:rev(A))) => *(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule t(*($1:t(A),b)) => *(A,b)
	private static Hop _applyRewrite112(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(*($1:t(A),b)) => *(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v1;
	}

	// Implementation of the rule t(*(b,$1:t(A))) => *(A,b)
	private static Hop _applyRewrite113(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(*(b,$1:t(A))) => *(A,b)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule rowSums(rev($1:*(a,B))) => *(a,rowSums($1:rev(B)))
	private static Hop _applyRewrite114(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim2() == -1 || hi_0_0_1.getDim1() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + hi_0_0_1.getNnz() + (hi_0_0_1.getDim1() * hi_0_0_1.getDim2()) + 30030.0);
		double costTo = (hi_0_0_1.getNnz() + (hi_0_0_1.getDim1() * hi_0_0_1.getDim2()) + (2.0 * (hi_0_0_1.getDim1() * 1.0)) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(rev($1:*(a,B))) => *(a,rowSums($1:rev(B)))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rowSums(rev($1:*(B,a))) => *(a,rowSums($1:rev(B)))
	private static Hop _applyRewrite115(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + hi_0_0_0.getNnz() + (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + 30030.0);
		double costTo = (hi_0_0_0.getNnz() + (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + (2.0 * (hi_0_0_0.getDim1() * 1.0)) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(rev($1:*(B,a))) => *(a,rowSums($1:rev(B)))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(rev($1:*(a,B))) => *(a,colSums($1:rev(B)))
	private static Hop _applyRewrite116(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim2() == -1 || hi_0_0_1.getDim1() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + hi_0_0_1.getNnz() + (hi_0_0_1.getDim1() * hi_0_0_1.getDim2()) + 30030.0);
		double costTo = (hi_0_0_1.getNnz() + (hi_0_0_1.getDim1() * hi_0_0_1.getDim2()) + (2.0 * (1.0 * hi_0_0_1.getDim2())) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(rev($1:*(a,B))) => *(a,colSums($1:rev(B)))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(rev($1:*(B,a))) => *(a,colSums($1:rev(B)))
	private static Hop _applyRewrite117(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + hi_0_0_0.getNnz() + (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + 30030.0);
		double costTo = (hi_0_0_0.getNnz() + (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + (2.0 * (1.0 * hi_0_0_0.getDim2())) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(rev($1:*(B,a))) => *(a,colSums($1:rev(B)))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rev(/(a,rev(B))) => /(a,B)
	private static Hop _applyRewrite118(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(/(a,rev(B))) => /(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule t(/(a,t(B))) => /(a,B)
	private static Hop _applyRewrite119(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(/(a,t(B))) => /(a,B)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v1);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v1;
	}

	// Implementation of the rule trace(*($1:/(a,C),B)) => *(a,trace(/(B,C)))
	private static Hop _applyRewrite120(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(*($1:/(a,C),B)) => *(a,trace(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(*(B,$1:/(a,C))) => *(a,trace(/(B,C)))
	private static Hop _applyRewrite121(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.DIV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(*(B,$1:/(a,C))) => *(a,trace(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule trace(/($1:*(a,B),C)) => *(a,trace(/(B,C)))
	private static Hop _applyRewrite122(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(/($1:*(a,B),C)) => *(a,trace(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(/($1:*(B,a),C)) => *(a,trace(/(B,C)))
	private static Hop _applyRewrite123(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(/($1:*(B,a),C)) => *(a,trace(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(*(C,A),*(B,A)) => *(A,+(B,C))
	private static Hop _applyRewrite124(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_0_1 != hi_1_1 )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_1.getNnz() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * Math.min(hi_0_0.getNnz(), hi_0_1.getNnz())) + (2.0 * Math.min(hi_1_0.getNnz(), hi_0_1.getNnz())) + (Math.min(hi_0_0.getNnz(), hi_0_1.getNnz()) + Math.min(hi_1_0.getNnz(), hi_0_1.getNnz())) + 30030.0);
		double costTo = ((hi_1_0.getNnz() + hi_0_0.getNnz()) + (2.0 * Math.min(hi_0_1.getNnz(), Math.min((hi_1_0.getNnz() + hi_0_0.getNnz()), (hi_1_0.getDim1() * hi_1_0.getDim2())))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(*(C,A),*(B,A)) => *(A,+(B,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(*(B,A),*(A,C)) => *(A,+(B,C))
	private static Hop _applyRewrite125(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_1.getNnz() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * Math.min(hi_0_0.getNnz(), hi_0_1.getNnz())) + (2.0 * Math.min(hi_0_1.getNnz(), hi_1_1.getNnz())) + (Math.min(hi_0_0.getNnz(), hi_0_1.getNnz()) + Math.min(hi_0_1.getNnz(), hi_1_1.getNnz())) + 30030.0);
		double costTo = ((hi_0_0.getNnz() + hi_1_1.getNnz()) + (2.0 * Math.min(hi_0_1.getNnz(), Math.min((hi_0_0.getNnz() + hi_1_1.getNnz()), (hi_0_0.getDim1() * hi_0_0.getDim2())))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(*(B,A),*(A,C)) => *(A,+(B,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(*(A,C),*(B,A)) => *(A,+(B,C))
	private static Hop _applyRewrite126(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_0_0 != hi_1_1 )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_1.getNnz() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * Math.min(hi_0_0.getNnz(), hi_0_1.getNnz())) + (2.0 * Math.min(hi_1_0.getNnz(), hi_0_0.getNnz())) + (Math.min(hi_0_0.getNnz(), hi_0_1.getNnz()) + Math.min(hi_1_0.getNnz(), hi_0_0.getNnz())) + 30030.0);
		double costTo = ((hi_1_0.getNnz() + hi_0_1.getNnz()) + (2.0 * Math.min(hi_0_0.getNnz(), Math.min((hi_1_0.getNnz() + hi_0_1.getNnz()), (hi_1_0.getDim1() * hi_1_0.getDim2())))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(*(A,C),*(B,A)) => *(A,+(B,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(*(A,C),*(A,B)) => *(A,+(B,C))
	private static Hop _applyRewrite127(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_1.getDim2() == -1 || hi_0_1.getNnz() == -1 || hi_0_0.getNnz() == -1 || hi_1_1.getDim1() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * Math.min(hi_0_0.getNnz(), hi_0_1.getNnz())) + (2.0 * Math.min(hi_0_0.getNnz(), hi_1_1.getNnz())) + (Math.min(hi_0_0.getNnz(), hi_0_1.getNnz()) + Math.min(hi_0_0.getNnz(), hi_1_1.getNnz())) + 30030.0);
		double costTo = ((hi_1_1.getNnz() + hi_0_1.getNnz()) + (2.0 * Math.min(hi_0_0.getNnz(), Math.min((hi_1_1.getNnz() + hi_0_1.getNnz()), (hi_1_1.getDim1() * hi_1_1.getDim2())))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(*(A,C),*(A,B)) => *(A,+(B,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule *(t($1:*(a,C)),b) => *(*(a,b),t(C))
	private static Hop _applyRewrite128(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(t($1:*(a,C)),b) => *(*(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(t($1:*(C,a)),b) => *(*(a,b),t(C))
	private static Hop _applyRewrite129(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(t($1:*(C,a)),b) => *(*(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,t($1:*(b,C))) => *(*(a,b),t(C))
	private static Hop _applyRewrite130(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,t($1:*(b,C))) => *(*(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(a,t($1:*(C,b))) => *(*(a,b),t(C))
	private static Hop _applyRewrite131(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,t($1:*(C,b))) => *(*(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(rev($1:*(a,C)),b) => *(*(a,b),rev(C))
	private static Hop _applyRewrite132(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(rev($1:*(a,C)),b) => *(*(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(rev($1:*(C,a)),b) => *(*(a,b),rev(C))
	private static Hop _applyRewrite133(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(rev($1:*(C,a)),b) => *(*(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,rev($1:*(b,C))) => *(*(a,b),rev(C))
	private static Hop _applyRewrite134(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,rev($1:*(b,C))) => *(*(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(a,rev($1:*(C,b))) => *(*(a,b),rev(C))
	private static Hop _applyRewrite135(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,rev($1:*(C,b))) => *(*(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule trace(!=(t(B),A)) => trace(!=(A,B))
	private static Hop _applyRewrite136(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(!=(t(B),A)) => trace(!=(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_0, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(!=(A,t(B))) => trace(!=(A,B))
	private static Hop _applyRewrite137(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(!=(A,t(B))) => trace(!=(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(-($1:t(A),b)) => trace(-(A,b))
	private static Hop _applyRewrite138(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(-($1:t(A),b)) => trace(-(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(-(a,$1:t(B))) => trace(-(a,B))
	private static Hop _applyRewrite139(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(-(a,$1:t(B))) => trace(-(a,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(-($1:t(A),B)) => trace(-(A,B))
	private static Hop _applyRewrite140(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(-($1:t(A),B)) => trace(-(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(-(A,$1:t(B))) => trace(-(A,B))
	private static Hop _applyRewrite141(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(-(A,$1:t(B))) => trace(-(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(+($1:t(B),A)) => trace(+(A,B))
	private static Hop _applyRewrite142(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+($1:t(B),A)) => trace(+(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_0, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(+(B,$1:t(A))) => trace(+(A,B))
	private static Hop _applyRewrite143(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+(B,$1:t(A))) => trace(+(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(+($1:t(A),b)) => trace(+(A,b))
	private static Hop _applyRewrite144(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+($1:t(A),b)) => trace(+(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(+(b,$1:t(A))) => trace(+(A,b))
	private static Hop _applyRewrite145(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+(b,$1:t(A))) => trace(+(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(!=(t(A),b)) => trace(!=(A,b))
	private static Hop _applyRewrite146(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(!=(t(A),b)) => trace(!=(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(!=(b,t(A))) => trace(!=(A,b))
	private static Hop _applyRewrite147(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(!=(b,t(A))) => trace(!=(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule sum(/($1:*(a,B),C)) => *(a,sum(/(B,C)))
	private static Hop _applyRewrite148(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(/($1:*(a,B),C)) => *(a,sum(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule sum(/($1:*(B,a),C)) => *(a,sum(/(B,C)))
	private static Hop _applyRewrite149(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(/($1:*(B,a),C)) => *(a,sum(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule sum(*($1:/(a,C),B)) => *(a,sum(/(B,C)))
	private static Hop _applyRewrite150(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(*($1:/(a,C),B)) => *(a,sum(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule sum(*(B,$1:/(a,C))) => *(a,sum(/(B,C)))
	private static Hop _applyRewrite151(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.DIV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(*(B,$1:/(a,C))) => *(a,sum(/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule *(t($1:/(a,C)),b) => /(*(a,b),t(C))
	private static Hop _applyRewrite152(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(t($1:/(a,C)),b) => /(*(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,t($1:/(b,C))) => /(*(a,b),t(C))
	private static Hop _applyRewrite153(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,t($1:/(b,C))) => /(*(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(rev($1:/(a,C)),b) => /(*(a,b),rev(C))
	private static Hop _applyRewrite154(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(rev($1:/(a,C)),b) => /(*(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,rev($1:/(b,C))) => /(*(a,b),rev(C))
	private static Hop _applyRewrite155(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,rev($1:/(b,C))) => /(*(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule %*%(colSums(B),*(a,C)) => *(a,%*%($1:colSums(B),C))
	private static Hop _applyRewrite156(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0 = (AggUnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.AggOp.SUM || !c_hi_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(colSums(B),*(a,C)) => *(a,%*%($1:colSums(B),C))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.SUM, Types.Direction.Col);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_1_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(colSums(B),*(C,a)) => *(a,%*%($1:colSums(B),C))
	private static Hop _applyRewrite157(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0 = (AggUnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.AggOp.SUM || !c_hi_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(colSums(B),*(C,a)) => *(a,%*%($1:colSums(B),C))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.SUM, Types.Direction.Col);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_1_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(*(a,B),rowSums(C)) => *(a,%*%(B,$1:rowSums(C)))
	private static Hop _applyRewrite158(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(a,B),rowSums(C)) => *(a,%*%(B,$1:rowSums(C)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_1_0, Types.AggOp.SUM, Types.Direction.Row);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_1, v1);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(*(B,a),rowSums(C)) => *(a,%*%(B,$1:rowSums(C)))
	private static Hop _applyRewrite159(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(B,a),rowSums(C)) => *(a,%*%(B,$1:rowSums(C)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_1_0, Types.AggOp.SUM, Types.Direction.Row);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0, v1);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule colSums(/($1:*(a,B),C)) => *(a,colSums($1:/(B,C)))
	private static Hop _applyRewrite160(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + (3.0 * hi_0_0_1.getNnz()) + hi_0_0.getNnz() + 30030.0);
		double costTo = ((3.0 * hi_0_0_1.getNnz()) + hi_0_0_1.getNnz() + (2.0 * (1.0 * hi_0_0_1.getDim2())) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(/($1:*(a,B),C)) => *(a,colSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(/($1:*(B,a),C)) => *(a,colSums($1:/(B,C)))
	private static Hop _applyRewrite161(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + (3.0 * hi_0_0_0.getNnz()) + hi_0_0.getNnz() + 30030.0);
		double costTo = ((3.0 * hi_0_0_0.getNnz()) + hi_0_0_0.getNnz() + (2.0 * (1.0 * hi_0_0_0.getDim2())) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(/($1:*(B,a),C)) => *(a,colSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(*($1:/(a,C),B)) => *(a,colSums($1:/(B,C)))
	private static Hop _applyRewrite162(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(*($1:/(a,C),B)) => *(a,colSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(*(B,$1:/(a,C))) => *(a,colSums($1:/(B,C)))
	private static Hop _applyRewrite163(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.DIV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(*(B,$1:/(a,C))) => *(a,colSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rowSums(*($1:/(a,C),B)) => *(a,rowSums($1:/(B,C)))
	private static Hop _applyRewrite164(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(*($1:/(a,C),B)) => *(a,rowSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rowSums(*(B,$1:/(a,C))) => *(a,rowSums($1:/(B,C)))
	private static Hop _applyRewrite165(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.DIV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(*(B,$1:/(a,C))) => *(a,rowSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rowSums(/($1:*(a,B),C)) => *(a,rowSums($1:/(B,C)))
	private static Hop _applyRewrite166(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim1() == -1 || hi_0_0.getNnz() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + (3.0 * hi_0_0_1.getNnz()) + hi_0_0.getNnz() + 30030.0);
		double costTo = ((3.0 * hi_0_0_1.getNnz()) + hi_0_0_1.getNnz() + (2.0 * (hi_0_0_1.getDim1() * 1.0)) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(/($1:*(a,B),C)) => *(a,rowSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rowSums(/($1:*(B,a),C)) => *(a,rowSums($1:/(B,C)))
	private static Hop _applyRewrite167(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 || hi_0_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + (3.0 * hi_0_0_0.getNnz()) + hi_0_0.getNnz() + 30030.0);
		double costTo = ((3.0 * hi_0_0_0.getNnz()) + hi_0_0_0.getNnz() + (2.0 * (hi_0_0_0.getDim1() * 1.0)) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(/($1:*(B,a),C)) => *(a,rowSums($1:/(B,C)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(!=(sum(A),A)) => trace(!=(A,trace(A)))
	private static Hop _applyRewrite168(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_0_0 != hi_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(!=(sum(A),A)) => trace(!=(A,trace(A)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v3 = HopRewriteUtils.createAggUnaryOp(v2, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(!=(A,sum(A))) => trace(!=(A,trace(A)))
	private static Hop _applyRewrite169(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_0 != hi_0_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(!=(A,sum(A))) => trace(!=(A,trace(A)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v3 = HopRewriteUtils.createAggUnaryOp(v2, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule *(/($1:*(a,C),D),b) => *(*(a,b),/(C,D))
	private static Hop _applyRewrite170(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/($1:*(a,C),D),b) => *(*(a,b),/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(/($1:*(C,a),D),b) => *(*(a,b),/(C,D))
	private static Hop _applyRewrite171(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/($1:*(C,a),D),b) => *(*(a,b),/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,/($1:*(b,C),D)) => *(*(a,b),/(C,D))
	private static Hop _applyRewrite172(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,/($1:*(b,C),D)) => *(*(a,b),/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0_1, hi_1_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(a,/($1:*(C,b),D)) => *(*(a,b),/(C,D))
	private static Hop _applyRewrite173(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,/($1:*(C,b),D)) => *(*(a,b),/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0_0, hi_1_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(/($1:/(a,C),D),b) => /(/(*(a,b),C),D)
	private static Hop _applyRewrite174(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/($1:/(a,C),D),b) => /(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v2, hi_0_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(/(a,C),/(b,D)) => /(/(*(a,b),C),D)
	private static Hop _applyRewrite175(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(/(a,C),/(b,D)) => /(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v2, hi_1_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule *(a,/($1:/(b,C),D)) => /(/(*(a,b),C),D)
	private static Hop _applyRewrite176(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,/($1:/(b,C),D)) => /(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_1, Types.OpOp2.DIV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v2, hi_1_1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule sum(-($1:t(A),b)) => sum(-(A,b))
	private static Hop _applyRewrite177(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(-($1:t(A),b)) => sum(-(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule sum(-(a,$1:t(B))) => sum(-(a,B))
	private static Hop _applyRewrite178(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(-(a,$1:t(B))) => sum(-(a,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule sum(!=(t(A),b)) => sum(!=(A,b))
	private static Hop _applyRewrite179(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(!=(t(A),b)) => sum(!=(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule sum(!=(b,t(A))) => sum(!=(A,b))
	private static Hop _applyRewrite180(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(!=(b,t(A))) => sum(!=(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule sum(+($1:t(A),b)) => sum(+(A,b))
	private static Hop _applyRewrite181(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(+($1:t(A),b)) => sum(+(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule sum(+(b,$1:t(A))) => sum(+(A,b))
	private static Hop _applyRewrite182(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(+(b,$1:t(A))) => sum(+(A,b))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(*($1:t(B),A)) => trace(*(A,B))
	private static Hop _applyRewrite183(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(*($1:t(B),A)) => trace(*(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_0, Types.OpOp2.MULT);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(*(B,$1:t(A))) => trace(*(A,B))
	private static Hop _applyRewrite184(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(*(B,$1:t(A))) => trace(*(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.MULT);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(t(A),t(B)) => t(!=(A,B))
	private static Hop _applyRewrite185(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 )
			return hi;


		double costFrom = (hi_0_0.getNnz() + hi_1_0.getNnz() + (hi_1_0.getDim2() * hi_0_0.getDim1()) + 30030.0);
		double costTo = ((hi_0_0.getDim1() * hi_1_0.getDim2()) + (hi_0_0.getDim1() * hi_0_0.getDim2()) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(t(A),t(B)) => t(!=(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(rev(A),rev(A)) => rev(!=(A,A))
	private static Hop _applyRewrite186(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(A),rev(A)) => rev(!=(A,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		ReorgOp v2 = HopRewriteUtils.createReorg(v1, Types.ReOrgOp.REV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule rev(-($1:rev(A),B)) => -(A,rev(B))
	private static Hop _applyRewrite187(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(-($1:rev(A),B)) => -(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_1, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(-(A,$1:rev(B))) => -(rev(A),B)
	private static Hop _applyRewrite188(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(-(A,$1:rev(B))) => -(rev(A),B)");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule t(-($1:t(A),B)) => -(A,t(B))
	private static Hop _applyRewrite189(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(-($1:t(A),B)) => -(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule t(-(A,$1:t(B))) => -(t(A),B)
	private static Hop _applyRewrite190(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(-(A,$1:t(B))) => -(t(A),B)");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule -(t(A),t(B)) => t(-(A,B))
	private static Hop _applyRewrite191(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(t(A),t(B)) => t(-(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(t(B),t(A)) => t(+(A,B))
	private static Hop _applyRewrite192(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t(B),t(A)) => t(+(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0_0, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(rev(-(b,A)),A) => !=(A,-(b,A))
	private static Hop _applyRewrite193(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(-(b,A)),A) => !=(A,-(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(-(b,A))) => !=(A,-(b,A))
	private static Hop _applyRewrite194(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(-(b,A))) => !=(A,-(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0_0, hi_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(-(b,rev(A)),A) => !=(A,-(b,A))
	private static Hop _applyRewrite195(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(b,rev(A)),A) => !=(A,-(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(-(b,A),rev(A)) => !=(A,-(b,A))
	private static Hop _applyRewrite196(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(b,A),rev(A)) => !=(A,-(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,-(b,rev(A))) => !=(A,-(b,A))
	private static Hop _applyRewrite197(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,-(b,rev(A))) => !=(A,-(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(rev(-(A,c)),A) => !=(A,-(A,c))
	private static Hop _applyRewrite198(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(-(A,c)),A) => !=(A,-(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(-(A,c))) => !=(A,-(A,c))
	private static Hop _applyRewrite199(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(-(A,c))) => !=(A,-(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(-(rev(A),c),A) => !=(A,-(A,c))
	private static Hop _applyRewrite200(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(rev(A),c),A) => !=(A,-(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,-(rev(A),c)) => !=(A,-(A,c))
	private static Hop _applyRewrite201(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,-(rev(A),c)) => !=(A,-(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(-(B,rev(A)),A) => !=(A,-(B,A))
	private static Hop _applyRewrite202(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(B,rev(A)),A) => !=(A,-(B,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(-(B,A),rev(A)) => !=(A,-(B,A))
	private static Hop _applyRewrite203(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(B,A),rev(A)) => !=(A,-(B,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,-(B,rev(A))) => !=(A,-(B,A))
	private static Hop _applyRewrite204(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,-(B,rev(A))) => !=(A,-(B,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(-(rev(A),C),A) => !=(A,-(A,C))
	private static Hop _applyRewrite205(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(rev(A),C),A) => !=(A,-(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(-(A,C),rev(A)) => !=(A,-(A,C))
	private static Hop _applyRewrite206(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(-(A,C),rev(A)) => !=(A,-(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,-(rev(A),C)) => !=(A,-(A,C))
	private static Hop _applyRewrite207(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,-(rev(A),C)) => !=(A,-(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule rev(!=(rev(A),B)) => !=(A,rev(B))
	private static Hop _applyRewrite208(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(rev(A),B)) => !=(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_1, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(!=(B,rev(A))) => !=(A,rev(B))
	private static Hop _applyRewrite209(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(B,rev(A))) => !=(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule t(!=(t(A),B)) => !=(A,t(B))
	private static Hop _applyRewrite210(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(!=(t(A),B)) => !=(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule t(!=(B,t(A))) => !=(A,t(B))
	private static Hop _applyRewrite211(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(!=(B,t(A))) => !=(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(rev(+(c,A)),A) => !=(A,+(A,c))
	private static Hop _applyRewrite212(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(+(c,A)),A) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(rev(+(A,c)),A) => !=(A,+(A,c))
	private static Hop _applyRewrite213(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(+(A,c)),A) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(+(c,A))) => !=(A,+(A,c))
	private static Hop _applyRewrite214(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(+(c,A))) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(+(A,c))) => !=(A,+(A,c))
	private static Hop _applyRewrite215(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(+(A,c))) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(+(rev(A),c),A) => !=(A,+(A,c))
	private static Hop _applyRewrite216(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(rev(A),c),A) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(+(c,rev(A)),A) => !=(A,+(A,c))
	private static Hop _applyRewrite217(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(c,rev(A)),A) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(+(c,A),rev(A)) => !=(A,+(A,c))
	private static Hop _applyRewrite218(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(c,A),rev(A)) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,+(rev(A),c)) => !=(A,+(A,c))
	private static Hop _applyRewrite219(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,+(rev(A),c)) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,+(c,rev(A))) => !=(A,+(A,c))
	private static Hop _applyRewrite220(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,+(c,rev(A))) => !=(A,+(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(+(rev(A),C),A) => !=(A,+(A,C))
	private static Hop _applyRewrite221(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(rev(A),C),A) => !=(A,+(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(+(C,rev(A)),A) => !=(A,+(A,C))
	private static Hop _applyRewrite222(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(C,rev(A)),A) => !=(A,+(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(+(C,A),rev(A)) => !=(A,+(A,C))
	private static Hop _applyRewrite223(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(C,A),rev(A)) => !=(A,+(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(+(A,C),rev(A)) => !=(A,+(A,C))
	private static Hop _applyRewrite224(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(+(A,C),rev(A)) => !=(A,+(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,+(rev(A),C)) => !=(A,+(A,C))
	private static Hop _applyRewrite225(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,+(rev(A),C)) => !=(A,+(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,+(C,rev(A))) => !=(A,+(A,C))
	private static Hop _applyRewrite226(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,+(C,rev(A))) => !=(A,+(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(!=(rev(A),c),A) => !=(A,!=(A,c))
	private static Hop _applyRewrite227(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(rev(A),c),A) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(!=(c,rev(A)),A) => !=(A,!=(A,c))
	private static Hop _applyRewrite228(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(c,rev(A)),A) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(!=(c,A),rev(A)) => !=(A,!=(A,c))
	private static Hop _applyRewrite229(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(c,A),rev(A)) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,!=(rev(A),c)) => !=(A,!=(A,c))
	private static Hop _applyRewrite230(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,!=(rev(A),c)) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,!=(c,rev(A))) => !=(A,!=(A,c))
	private static Hop _applyRewrite231(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,!=(c,rev(A))) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(rev(!=(c,A)),A) => !=(A,!=(A,c))
	private static Hop _applyRewrite232(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(!=(c,A)),A) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(rev(!=(A,c)),A) => !=(A,!=(A,c))
	private static Hop _applyRewrite233(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(!=(A,c)),A) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(!=(c,A))) => !=(A,!=(A,c))
	private static Hop _applyRewrite234(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(!=(c,A))) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(!=(A,c))) => !=(A,!=(A,c))
	private static Hop _applyRewrite235(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(!=(A,c))) => !=(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(!=(rev(A),C),A) => !=(A,!=(A,C))
	private static Hop _applyRewrite236(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(rev(A),C),A) => !=(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(!=(C,rev(A)),A) => !=(A,!=(A,C))
	private static Hop _applyRewrite237(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(C,rev(A)),A) => !=(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(!=(C,A),rev(A)) => !=(A,!=(A,C))
	private static Hop _applyRewrite238(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(C,A),rev(A)) => !=(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(!=(A,C),rev(A)) => !=(A,!=(A,C))
	private static Hop _applyRewrite239(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(!=(A,C),rev(A)) => !=(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,!=(rev(A),C)) => !=(A,!=(A,C))
	private static Hop _applyRewrite240(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,!=(rev(A),C)) => !=(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,!=(C,rev(A))) => !=(A,!=(A,C))
	private static Hop _applyRewrite241(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,!=(C,rev(A))) => !=(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule rev(+($1:rev(A),B)) => +(A,rev(B))
	private static Hop _applyRewrite242(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(+($1:rev(A),B)) => +(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_1, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(+(B,$1:rev(A))) => +(A,rev(B))
	private static Hop _applyRewrite243(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(+(B,$1:rev(A))) => +(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule t(+($1:t(A),B)) => +(A,t(B))
	private static Hop _applyRewrite244(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(+($1:t(A),B)) => +(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule t(+(B,$1:t(A))) => +(A,t(B))
	private static Hop _applyRewrite245(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(+(B,$1:t(A))) => +(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(!=(rev(A),c),A) => +(A,!=(A,c))
	private static Hop _applyRewrite246(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(!=(rev(A),c),A) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(!=(c,rev(A)),A) => +(A,!=(A,c))
	private static Hop _applyRewrite247(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(!=(c,rev(A)),A) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(A,!=(rev(A),c)) => +(A,!=(A,c))
	private static Hop _applyRewrite248(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,!=(rev(A),c)) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,!=(c,rev(A))) => +(A,!=(A,c))
	private static Hop _applyRewrite249(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,!=(c,rev(A))) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule +(rev($1:!=(c,A)),A) => +(A,!=(A,c))
	private static Hop _applyRewrite250(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:!=(c,A)),A) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(rev($1:!=(A,c)),A) => +(A,!=(A,c))
	private static Hop _applyRewrite251(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:!=(A,c)),A) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(A,rev($1:!=(c,A))) => +(A,!=(A,c))
	private static Hop _applyRewrite252(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,rev($1:!=(c,A))) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,rev($1:!=(A,c))) => +(A,!=(A,c))
	private static Hop _applyRewrite253(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,rev($1:!=(A,c))) => +(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(!=(rev(A),C),A) => +(A,!=(A,C))
	private static Hop _applyRewrite254(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(!=(rev(A),C),A) => +(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(!=(C,rev(A)),A) => +(A,!=(A,C))
	private static Hop _applyRewrite255(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(!=(C,rev(A)),A) => +(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(A,!=(rev(A),C)) => +(A,!=(A,C))
	private static Hop _applyRewrite256(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,!=(rev(A),C)) => +(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,!=(C,rev(A))) => +(A,!=(A,C))
	private static Hop _applyRewrite257(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,!=(C,rev(A))) => +(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(rev($1:!=(A,b)),A) => -(!=(A,b),A)
	private static Hop _applyRewrite258(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(rev($1:!=(A,b)),A) => -(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule -(A,!=(rev(A),c)) => -(A,!=(A,c))
	private static Hop _applyRewrite259(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,!=(rev(A),c)) => -(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,!=(c,rev(A))) => -(A,!=(A,c))
	private static Hop _applyRewrite260(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,!=(c,rev(A))) => -(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(A,rev($1:!=(c,A))) => -(A,!=(A,c))
	private static Hop _applyRewrite261(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,rev($1:!=(c,A))) => -(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,rev($1:!=(A,c))) => -(A,!=(A,c))
	private static Hop _applyRewrite262(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,rev($1:!=(A,c))) => -(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,!=(rev(A),C)) => -(A,!=(A,C))
	private static Hop _applyRewrite263(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,!=(rev(A),C)) => -(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,!=(C,rev(A))) => -(A,!=(A,C))
	private static Hop _applyRewrite264(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,!=(C,rev(A))) => -(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(t($1:-(A,b)),c) => -(t(A),+(b,c))
	private static Hop _applyRewrite265(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(t($1:-(A,b)),c) => -(t(A),+(b,c))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(t($1:-(a,C)),b) => -(-(a,b),t(C))
	private static Hop _applyRewrite266(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(t($1:-(a,C)),b) => -(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(a,t($1:+(b,C))) => -(-(a,b),t(C))
	private static Hop _applyRewrite267(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,t($1:+(b,C))) => -(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(a,t($1:+(C,b))) => -(-(a,b),t(C))
	private static Hop _applyRewrite268(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,t($1:+(C,b))) => -(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(rev($1:-(A,b)),c) => -(rev(A),+(b,c))
	private static Hop _applyRewrite269(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(rev($1:-(A,b)),c) => -(rev(A),+(b,c))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(rev($1:-(a,C)),b) => -(-(a,b),rev(C))
	private static Hop _applyRewrite270(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(rev($1:-(a,C)),b) => -(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(a,rev($1:+(b,C))) => -(-(a,b),rev(C))
	private static Hop _applyRewrite271(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,rev($1:+(b,C))) => -(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(a,rev($1:+(C,b))) => -(-(a,b),rev(C))
	private static Hop _applyRewrite272(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,rev($1:+(C,b))) => -(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(-($1:-(a,D),C),b) => -(-(a,b),+(C,D))
	private static Hop _applyRewrite273(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-($1:-(a,D),C),b) => -(-(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(-(a,C),+(b,D)) => -(-(a,b),+(C,D))
	private static Hop _applyRewrite274(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(a,C),+(b,D)) => -(-(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(-(a,D),+(C,b)) => -(-(a,b),+(C,D))
	private static Hop _applyRewrite275(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(a,D),+(C,b)) => -(-(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(-($1:-(A,c),B),d) => -(A,+(B,+(c,d)))
	private static Hop _applyRewrite276(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-($1:-(A,c),B),d) => -(A,+(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(-(A,$1:+(c,B)),d) => -(A,+(B,+(c,d)))
	private static Hop _applyRewrite277(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.PLUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,$1:+(c,B)),d) => -(A,+(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule -(-(A,$1:+(B,c)),d) => -(A,+(B,+(c,d)))
	private static Hop _applyRewrite278(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.PLUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,$1:+(B,c)),d) => -(A,+(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule -(-(A,c),+(d,B)) => -(A,+(B,+(c,d)))
	private static Hop _applyRewrite279(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,c),+(d,B)) => -(A,+(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(-(A,c),+(B,d)) => -(A,+(B,+(c,d)))
	private static Hop _applyRewrite280(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,c),+(B,d)) => -(A,+(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(a,rev($1:-(C,b))) => -(+(a,b),rev(C))
	private static Hop _applyRewrite281(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,rev($1:-(C,b))) => -(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(rev($1:-(a,C)),b) => -(+(a,b),rev(C))
	private static Hop _applyRewrite282(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:-(a,C)),b) => -(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(a,rev($1:-(b,C))) => -(+(a,b),rev(C))
	private static Hop _applyRewrite283(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,rev($1:-(b,C))) => -(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(a,rev($1:-(b,C))) => +(-(a,b),rev(C))
	private static Hop _applyRewrite284(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,rev($1:-(b,C))) => +(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(rev($1:+(a,C)),b) => +(-(a,b),rev(C))
	private static Hop _applyRewrite285(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(rev($1:+(a,C)),b) => +(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(rev($1:+(C,a)),b) => +(-(a,b),rev(C))
	private static Hop _applyRewrite286(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(rev($1:+(C,a)),b) => +(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(rev($1:-(C,b)),a) => +(-(a,b),rev(C))
	private static Hop _applyRewrite287(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:-(C,b)),a) => +(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_0_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(a,rev($1:-(C,b))) => +(-(a,b),rev(C))
	private static Hop _applyRewrite288(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,rev($1:-(C,b))) => +(-(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(rev($1:+(a,C)),b) => +(+(a,b),rev(C))
	private static Hop _applyRewrite289(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:+(a,C)),b) => +(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(rev($1:+(C,a)),b) => +(+(a,b),rev(C))
	private static Hop _applyRewrite290(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:+(C,a)),b) => +(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(a,rev($1:+(b,C))) => +(+(a,b),rev(C))
	private static Hop _applyRewrite291(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,rev($1:+(b,C))) => +(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(a,rev($1:+(C,b))) => +(+(a,b),rev(C))
	private static Hop _applyRewrite292(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,rev($1:+(C,b))) => +(+(a,b),rev(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(-(a,C),-(D,b)) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite293(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(a,C),-(D,b)) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(a,-(C,$1:-(b,D))) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite294(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MINUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,-(C,$1:-(b,D))) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0, hi_1_1_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule -(a,+($1:-(D,b),C)) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite295(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,+($1:-(D,b),C)) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0_0, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(a,+(D,$1:-(C,b))) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite296(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MINUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,+(D,$1:-(C,b))) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1_0, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule +(-($1:-(a,C),D),b) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite297(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:-(a,C),D),b) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(-(a,D),-(b,C)) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite298(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(a,D),-(b,C)) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, hi_0_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule +(a,-($1:-(b,D),C)) => -(+(a,b),+(C,D))
	private static Hop _applyRewrite299(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,-($1:-(b,D),C)) => -(+(a,b),+(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0_1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(-(A,$1:-(c,B)),d) => +(A,-(B,+(c,d)))
	private static Hop _applyRewrite300(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MINUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,$1:-(c,B)),d) => +(A,-(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_1, v1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule -(-(B,c),-(d,A)) => +(A,-(B,+(c,d)))
	private static Hop _applyRewrite301(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(B,c),-(d,A)) => +(A,-(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+($1:-(B,c),A),d) => +(A,-(B,+(c,d)))
	private static Hop _applyRewrite302(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+($1:-(B,c),A),d) => +(A,-(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(+(A,$1:-(B,c)),d) => +(A,-(B,+(c,d)))
	private static Hop _applyRewrite303(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MINUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(A,$1:-(B,c)),d) => +(A,-(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule +(-(B,c),-(A,d)) => +(A,-(B,+(c,d)))
	private static Hop _applyRewrite304(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(B,c),-(A,d)) => +(A,-(B,+(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(b,-($1:-(D,c),A)) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite305(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-($1:-(D,c),A)) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(b,-(D,$1:+(c,A))) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite306(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.PLUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-(D,$1:+(c,A))) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule -(b,-(D,$1:+(A,c))) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite307(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.PLUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-(D,$1:+(A,c))) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule -(+(b,A),-(D,c)) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite308(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(b,A),-(D,c)) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+(A,b),-(D,c)) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite309(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(A,b),-(D,c)) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule +(-(A,$1:-(D,b)),c) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite310(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MINUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(A,$1:-(D,b)),c) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule +(b,-(A,$1:-(D,c))) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite311(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MINUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-(A,$1:-(D,c))) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule +(-($1:+(b,A),D),c) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite312(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:+(b,A),D),c) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(-($1:+(A,b),D),c) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite313(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:+(A,b),D),c) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(b,-($1:+(c,A),D)) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite314(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-($1:+(c,A),D)) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(b,-($1:+(A,c),D)) => +(A,-(+(b,c),D))
	private static Hop _applyRewrite315(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-($1:+(A,c),D)) => +(A,-(+(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(c,-($1:-(d,B),A)) => +(A,+(B,-(c,d)))
	private static Hop _applyRewrite316(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(c,-($1:-(d,B),A)) => +(A,+(B,-(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(+(c,B),-(d,A)) => +(A,+(B,-(c,d)))
	private static Hop _applyRewrite317(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(c,B),-(d,A)) => +(A,+(B,-(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+(B,c),-(d,A)) => +(A,+(B,-(c,d)))
	private static Hop _applyRewrite318(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(B,c),-(d,A)) => +(A,+(B,-(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule +(-(A,$1:-(d,B)),c) => +(A,+(B,-(c,d)))
	private static Hop _applyRewrite319(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MINUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(A,$1:-(d,B)),c) => +(A,+(B,-(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule +(c,-(A,$1:-(d,B))) => +(A,+(B,-(c,d)))
	private static Hop _applyRewrite320(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MINUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(c,-(A,$1:-(d,B))) => +(A,+(B,-(c,d)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1_1, v1, Types.OpOp2.PLUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule -(-(A,$1:-(D,b)),c) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite321(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MINUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,$1:-(D,b)),c) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_1, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule -(-(b,D),-(c,A)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite322(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(b,D),-(c,A)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(-(A,c),-(D,b)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite323(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(A,c),-(D,b)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(b,-(D,$1:-(A,c))) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite324(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MINUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-(D,$1:-(A,c))) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule -(-($1:+(b,A),D),c) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite325(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-($1:+(b,A),D),c) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(-($1:+(A,b),D),c) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite326(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-($1:+(A,b),D),c) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(b,-($1:+(c,D),A)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite327(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-($1:+(c,D),A)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(b,-($1:+(D,c),A)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite328(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,-($1:+(D,c),A)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(+($1:-(b,D),A),c) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite329(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+($1:-(b,D),A),c) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(+(b,A),+(c,D)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite330(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(b,A),+(c,D)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+(b,A),+(D,c)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite331(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(b,A),+(D,c)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+(A,b),+(c,D)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite332(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(A,b),+(c,D)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+(A,b),+(D,c)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite333(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(A,b),+(D,c)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule -(+(A,$1:-(b,D)),c) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite334(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MINUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(A,$1:-(b,D)),c) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule -(b,+($1:-(c,A),D)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite335(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,+($1:-(c,A),D)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(b,+(D,$1:-(c,A))) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite336(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MINUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(b,+(D,$1:-(c,A))) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_1_1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule +(-($1:-(A,c),D),b) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite337(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:-(A,c),D),b) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(-(b,D),-(A,c)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite338(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(b,D),-(A,c)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule +(-(A,c),-(b,D)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite339(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(A,c),-(b,D)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule +(b,-($1:-(A,c),D)) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite340(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-($1:-(A,c),D)) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(-(A,$1:+(c,D)),b) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite341(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.PLUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(A,$1:+(c,D)),b) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule +(-(A,$1:+(D,c)),b) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite342(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.PLUS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(A,$1:+(D,c)),b) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule +(b,-(A,$1:+(c,D))) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite343(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.PLUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-(A,$1:+(c,D))) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1_1, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule +(b,-(A,$1:+(D,c))) => +(A,-(-(b,c),D))
	private static Hop _applyRewrite344(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.PLUS || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(b,-(A,$1:+(D,c))) => +(A,-(-(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_1, Types.OpOp2.MINUS);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1_0, Types.OpOp2.MINUS);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_1_0, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule -(a,t($1:-(C,b))) => -(+(a,b),t(C))
	private static Hop _applyRewrite345(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,t($1:-(C,b))) => -(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(t($1:-(a,C)),b) => -(+(a,b),t(C))
	private static Hop _applyRewrite346(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t($1:-(a,C)),b) => -(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(a,t($1:-(b,C))) => -(+(a,b),t(C))
	private static Hop _applyRewrite347(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,t($1:-(b,C))) => -(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule -(t($1:+(a,C)),b) => +(-(a,b),t(C))
	private static Hop _applyRewrite348(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(t($1:+(a,C)),b) => +(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(t($1:+(C,a)),b) => +(-(a,b),t(C))
	private static Hop _applyRewrite349(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(t($1:+(C,a)),b) => +(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule -(a,t($1:-(b,C))) => +(-(a,b),t(C))
	private static Hop _applyRewrite350(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,t($1:-(b,C))) => +(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(t($1:-(C,b)),a) => +(-(a,b),t(C))
	private static Hop _applyRewrite351(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MINUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t($1:-(C,b)),a) => +(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1, hi_0_0_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(a,t($1:-(C,b))) => +(-(a,b),t(C))
	private static Hop _applyRewrite352(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MINUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,t($1:-(C,b))) => +(-(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MINUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(t($1:+(a,C)),b) => +(+(a,b),t(C))
	private static Hop _applyRewrite353(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t($1:+(a,C)),b) => +(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(t($1:+(C,a)),b) => +(+(a,b),t(C))
	private static Hop _applyRewrite354(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.PLUS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t($1:+(C,a)),b) => +(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_0_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule +(a,t($1:+(b,C))) => +(+(a,b),t(C))
	private static Hop _applyRewrite355(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,t($1:+(b,C))) => +(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule +(a,t($1:+(C,b))) => +(+(a,b),t(C))
	private static Hop _applyRewrite356(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.PLUS || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,t($1:+(C,b))) => +(+(a,b),t(C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.PLUS);
		ReorgOp v2 = HopRewriteUtils.createTranspose(hi_1_0_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule colSums(-($1:t(A),b)) => t(rowSums($1:-(A,b)))
	private static Hop _applyRewrite357(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(-($1:t(A),b)) => t(rowSums($1:-(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(-(a,$1:t(B))) => t(rowSums($1:-(a,B)))
	private static Hop _applyRewrite358(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(-(a,$1:t(B))) => t(rowSums($1:-(a,B)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rowSums(-($1:t(A),b)) => t(colSums($1:-(A,b)))
	private static Hop _applyRewrite359(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(-($1:t(A),b)) => t(colSums($1:-(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rowSums(-(a,$1:t(B))) => t(colSums($1:-(a,B)))
	private static Hop _applyRewrite360(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(-(a,$1:t(B))) => t(colSums($1:-(a,B)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.MINUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule colSums(!=(t(A),b)) => t(rowSums($1:!=(A,b)))
	private static Hop _applyRewrite361(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 )
			return hi;


		double costFrom = (hi_0_0_0.getNnz() + (hi_0_0_0.getDim2() * hi_0_0_0.getDim1()) + (hi_0_0_0.getDim2() * hi_0_0_0.getDim1()) + 30030.0);
		double costTo = ((hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + (hi_0_0_0.getDim1() * 1.0) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(!=(t(A),b)) => t(rowSums($1:!=(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(!=(b,t(A))) => t(rowSums($1:!=(A,b)))
	private static Hop _applyRewrite362(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1_0.getDim1() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) + (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) + 30030.0);
		double costTo = ((hi_0_1_0.getDim1() * hi_0_1_0.getDim2()) + (hi_0_1_0.getDim1() * hi_0_1_0.getDim2()) + (hi_0_1_0.getDim1() * 1.0) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(!=(b,t(A))) => t(rowSums($1:!=(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rowSums(!=(t(A),b)) => t(colSums($1:!=(A,b)))
	private static Hop _applyRewrite363(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 )
			return hi;


		double costFrom = (hi_0_0_0.getNnz() + (hi_0_0_0.getDim2() * hi_0_0_0.getDim1()) + (hi_0_0_0.getDim2() * hi_0_0_0.getDim1()) + 30030.0);
		double costTo = ((hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + (1.0 * hi_0_0_0.getDim2()) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(!=(t(A),b)) => t(colSums($1:!=(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rowSums(!=(b,t(A))) => t(colSums($1:!=(A,b)))
	private static Hop _applyRewrite364(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1_0.getDim1() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) + (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) + 30030.0);
		double costTo = ((hi_0_1_0.getDim1() * hi_0_1_0.getDim2()) + (hi_0_1_0.getDim1() * hi_0_1_0.getDim2()) + (1.0 * hi_0_1_0.getDim2()) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(!=(b,t(A))) => t(colSums($1:!=(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule colSums(+($1:t(A),b)) => t(rowSums($1:+(A,b)))
	private static Hop _applyRewrite365(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(+($1:t(A),b)) => t(rowSums($1:+(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule colSums(+(b,$1:t(A))) => t(rowSums($1:+(A,b)))
	private static Hop _applyRewrite366(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(+(b,$1:t(A))) => t(rowSums($1:+(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rowSums(+($1:t(A),b)) => t(colSums($1:+(A,b)))
	private static Hop _applyRewrite367(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(+($1:t(A),b)) => t(colSums($1:+(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule rowSums(+(b,$1:t(A))) => t(colSums($1:+(A,b)))
	private static Hop _applyRewrite368(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(+(b,$1:t(A))) => t(colSums($1:+(A,b)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.PLUS);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule trace(/(a,t(B))) => trace(/(a,B))
	private static Hop _applyRewrite369(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(/(a,t(B))) => trace(/(a,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(/($1:t(A),B)) => trace(/(A,B))
	private static Hop _applyRewrite370(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(/($1:t(A),B)) => trace(/(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule trace(/(A,t(B))) => trace(/(A,B))
	private static Hop _applyRewrite371(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(/(A,t(B))) => trace(/(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule *(t(A),t(B)) => t(*(A,B))
	private static Hop _applyRewrite372(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(t(A),t(B)) => t(*(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MULT);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(*(rev(A),c),A) => !=(A,*(A,c))
	private static Hop _applyRewrite373(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(rev(A),c),A) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(*(c,rev(A)),A) => !=(A,*(A,c))
	private static Hop _applyRewrite374(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(c,rev(A)),A) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(*(c,A),rev(A)) => !=(A,*(A,c))
	private static Hop _applyRewrite375(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(c,A),rev(A)) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,*(rev(A),c)) => !=(A,*(A,c))
	private static Hop _applyRewrite376(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,*(rev(A),c)) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,*(c,rev(A))) => !=(A,*(A,c))
	private static Hop _applyRewrite377(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,*(c,rev(A))) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(rev(*(c,A)),A) => !=(A,*(A,c))
	private static Hop _applyRewrite378(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(*(c,A)),A) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(rev(*(A,c)),A) => !=(A,*(A,c))
	private static Hop _applyRewrite379(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(*(A,c)),A) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(*(c,A))) => !=(A,*(A,c))
	private static Hop _applyRewrite380(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(*(c,A))) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(*(A,c))) => !=(A,*(A,c))
	private static Hop _applyRewrite381(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(*(A,c))) => !=(A,*(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(*(rev(A),C),A) => !=(A,*(A,C))
	private static Hop _applyRewrite382(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(rev(A),C),A) => !=(A,*(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(*(C,rev(A)),A) => !=(A,*(A,C))
	private static Hop _applyRewrite383(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(C,rev(A)),A) => !=(A,*(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(*(C,A),rev(A)) => !=(A,*(A,C))
	private static Hop _applyRewrite384(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(C,A),rev(A)) => !=(A,*(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(*(A,C),rev(A)) => !=(A,*(A,C))
	private static Hop _applyRewrite385(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(*(A,C),rev(A)) => !=(A,*(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,*(rev(A),C)) => !=(A,*(A,C))
	private static Hop _applyRewrite386(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,*(rev(A),C)) => !=(A,*(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,*(C,rev(A))) => !=(A,*(A,C))
	private static Hop _applyRewrite387(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,*(C,rev(A))) => !=(A,*(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule rev(*($1:rev(A),B)) => *(A,rev(B))
	private static Hop _applyRewrite388(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_1.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 || hi_0_1.getNnz() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = (hi_0_0_0.getNnz() + (2.0 * Math.min((hi_0_0_0.getDim1() * hi_0_0_0.getDim2()), hi_0_1.getNnz())) + Math.min((hi_0_0_0.getDim1() * hi_0_0_0.getDim2()), hi_0_1.getNnz()) + 30030.0);
		double costTo = (hi_0_1.getNnz() + (2.0 * Math.min(hi_0_0_0.getNnz(), (hi_0_1.getDim1() * hi_0_1.getDim2()))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(*($1:rev(A),B)) => *(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_1, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(*(B,$1:rev(A))) => *(A,rev(B))
	private static Hop _applyRewrite389(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_1_0.getDim1() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (2.0 * Math.min(hi_0_0.getNnz(), (hi_0_1_0.getDim1() * hi_0_1_0.getDim2()))) + Math.min(hi_0_0.getNnz(), (hi_0_1_0.getDim1() * hi_0_1_0.getDim2())) + 30030.0);
		double costTo = (hi_0_0.getNnz() + (2.0 * Math.min(hi_0_1_0.getNnz(), (hi_0_0.getDim1() * hi_0_0.getDim2()))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(*(B,$1:rev(A))) => *(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule t(*($1:t(A),B)) => *(A,t(B))
	private static Hop _applyRewrite390(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_1.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 || hi_0_1.getNnz() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = (hi_0_0_0.getNnz() + (2.0 * Math.min((hi_0_0_0.getDim2() * hi_0_0_0.getDim1()), hi_0_1.getNnz())) + Math.min((hi_0_0_0.getDim2() * hi_0_0_0.getDim1()), hi_0_1.getNnz()) + 30030.0);
		double costTo = (hi_0_1.getNnz() + (2.0 * Math.min(hi_0_0_0.getNnz(), (hi_0_1.getDim2() * hi_0_1.getDim1()))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(*($1:t(A),B)) => *(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule t(*(B,$1:t(A))) => *(A,t(B))
	private static Hop _applyRewrite391(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_1_0.getDim1() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (2.0 * Math.min(hi_0_0.getNnz(), (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()))) + Math.min(hi_0_0.getNnz(), (hi_0_1_0.getDim2() * hi_0_1_0.getDim1())) + 30030.0);
		double costTo = (hi_0_0.getNnz() + (2.0 * Math.min(hi_0_1_0.getNnz(), (hi_0_0.getDim2() * hi_0_0.getDim1()))) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(*(B,$1:t(A))) => *(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule *(!=(rev(A),c),A) => *(A,!=(A,c))
	private static Hop _applyRewrite392(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(!=(rev(A),c),A) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule *(!=(c,rev(A)),A) => *(A,!=(A,c))
	private static Hop _applyRewrite393(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(!=(c,rev(A)),A) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule *(A,!=(rev(A),c)) => *(A,!=(A,c))
	private static Hop _applyRewrite394(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,!=(rev(A),c)) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule *(A,!=(c,rev(A))) => *(A,!=(A,c))
	private static Hop _applyRewrite395(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,!=(c,rev(A))) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule *(rev($1:!=(c,A)),A) => *(A,!=(A,c))
	private static Hop _applyRewrite396(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(rev($1:!=(c,A)),A) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule *(rev($1:!=(A,c)),A) => *(A,!=(A,c))
	private static Hop _applyRewrite397(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(rev($1:!=(A,c)),A) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule *(A,rev($1:!=(c,A))) => *(A,!=(A,c))
	private static Hop _applyRewrite398(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,rev($1:!=(c,A))) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule *(A,rev($1:!=(A,c))) => *(A,!=(A,c))
	private static Hop _applyRewrite399(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,rev($1:!=(A,c))) => *(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule *(!=(rev(A),C),A) => *(A,!=(A,C))
	private static Hop _applyRewrite400(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(!=(rev(A),C),A) => *(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule *(!=(C,rev(A)),A) => *(A,!=(A,C))
	private static Hop _applyRewrite401(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(!=(C,rev(A)),A) => *(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule *(A,!=(rev(A),C)) => *(A,!=(A,C))
	private static Hop _applyRewrite402(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,!=(rev(A),C)) => *(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule *(A,!=(C,rev(A))) => *(A,!=(A,C))
	private static Hop _applyRewrite403(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,!=(C,rev(A))) => *(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule sum(/(a,t(B))) => sum(/(a,B))
	private static Hop _applyRewrite404(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.RowCol) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: sum(/(a,t(B))) => sum(/(a,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.RowCol);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule rev(/($1:rev(A),B)) => /(A,rev(B))
	private static Hop _applyRewrite405(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(/($1:rev(A),B)) => /(A,rev(B))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_1, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(/(A,rev(B))) => /(rev(A),B)
	private static Hop _applyRewrite406(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (3.0 * hi_0_0.getNnz()) + hi_0_0.getNnz() + 30030.0);
		double costTo = (hi_0_0.getNnz() + (3.0 * (hi_0_0.getDim1() * hi_0_0.getDim2())) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(/(A,rev(B))) => /(rev(A),B)");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0, Types.ReOrgOp.REV);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule t(/($1:t(A),B)) => /(A,t(B))
	private static Hop _applyRewrite407(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(/($1:t(A),B)) => /(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule t(/(A,t(B))) => /(t(A),B)
	private static Hop _applyRewrite408(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (3.0 * hi_0_0.getNnz()) + hi_0_0.getNnz() + 30030.0);
		double costTo = (hi_0_0.getNnz() + (3.0 * (hi_0_0.getDim2() * hi_0_0.getDim1())) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(/(A,t(B))) => /(t(A),B)");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_0, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule /(t(A),t(B)) => t(/(A,B))
	private static Hop _applyRewrite409(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(t(A),t(B)) => t(/(A,B))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.DIV);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(/(b,rev(A)),A) => !=(A,/(b,A))
	private static Hop _applyRewrite410(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(/(b,rev(A)),A) => !=(A,/(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(/(b,A),rev(A)) => !=(A,/(b,A))
	private static Hop _applyRewrite411(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(/(b,A),rev(A)) => !=(A,/(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,/(b,rev(A))) => !=(A,/(b,A))
	private static Hop _applyRewrite412(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,/(b,rev(A))) => !=(A,/(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(rev(/(b,A)),A) => !=(A,/(b,A))
	private static Hop _applyRewrite413(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(/(b,A)),A) => !=(A,/(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(/(b,A))) => !=(A,/(b,A))
	private static Hop _applyRewrite414(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(/(b,A))) => !=(A,/(b,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0_0, hi_0, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(/(B,rev(A)),A) => !=(A,/(B,A))
	private static Hop _applyRewrite415(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(/(B,rev(A)),A) => !=(A,/(B,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(/(B,A),rev(A)) => !=(A,/(B,A))
	private static Hop _applyRewrite416(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_1 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(/(B,A),rev(A)) => !=(A,/(B,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,/(B,rev(A))) => !=(A,/(B,A))
	private static Hop _applyRewrite417(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,/(B,rev(A))) => !=(A,/(B,A))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_0, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(/(rev(A),C),A) => !=(A,/(A,C))
	private static Hop _applyRewrite418(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(/(rev(A),C),A) => !=(A,/(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(/(A,C),rev(A)) => !=(A,/(A,C))
	private static Hop _applyRewrite419(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(/(A,C),rev(A)) => !=(A,/(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(A,/(rev(A),C)) => !=(A,/(A,C))
	private static Hop _applyRewrite420(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,/(rev(A),C)) => !=(A,/(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.DIV);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule /(rev($1:!=(A,b)),A) => /(!=(A,b),A)
	private static Hop _applyRewrite421(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(rev($1:!=(A,b)),A) => /(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_0, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule /(A,rev(!=(c,A))) => /(A,!=(A,c))
	private static Hop _applyRewrite422(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,rev(!=(c,A))) => /(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule /(A,rev(!=(A,c))) => /(A,!=(A,c))
	private static Hop _applyRewrite423(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,rev(!=(A,c))) => /(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule /(A,!=(rev(A),c)) => /(A,!=(A,c))
	private static Hop _applyRewrite424(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,!=(rev(A),c)) => /(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule /(A,!=(c,rev(A))) => /(A,!=(A,c))
	private static Hop _applyRewrite425(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,!=(c,rev(A))) => /(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule /(A,!=(rev(A),C)) => /(A,!=(A,C))
	private static Hop _applyRewrite426(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,!=(rev(A),C)) => /(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule /(A,!=(C,rev(A))) => /(A,!=(A,C))
	private static Hop _applyRewrite427(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.DIV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: /(A,!=(C,rev(A))) => /(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule colSums(/(a,t(B))) => t(rowSums($1:/(a,B)))
	private static Hop _applyRewrite428(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1_0.getDim1() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (3.0 * (hi_0_1_0.getDim2() * hi_0_1_0.getDim1())) + (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) + 30030.0);
		double costTo = ((3.0 * (hi_0_1_0.getDim1() * hi_0_1_0.getDim2())) + (hi_0_1_0.getDim1() * hi_0_1_0.getDim2()) + (hi_0_1_0.getDim1() * 1.0) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: colSums(/(a,t(B))) => t(rowSums($1:/(a,B)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule rowSums(/(a,t(B))) => t(colSums($1:/(a,B)))
	private static Hop _applyRewrite429(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1_0.getDim1() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (3.0 * (hi_0_1_0.getDim2() * hi_0_1_0.getDim1())) + (hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) + 30030.0);
		double costTo = ((3.0 * (hi_0_1_0.getDim1() * hi_0_1_0.getDim2())) + (hi_0_1_0.getDim1() * hi_0_1_0.getDim2()) + (1.0 * hi_0_1_0.getDim2()) + 30030.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rowSums(/(a,t(B))) => t(colSums($1:/(a,B)))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_0, Types.OpOp2.DIV);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.SUM, Types.Direction.Col);
		ReorgOp v3 = HopRewriteUtils.createTranspose(v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule !=(t(A),colSums(A)) => !=(A,cast.MATRIX(sum(A)))
	private static Hop _applyRewrite430(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_0_0 != hi_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(t(A),colSums(A)) => !=(A,cast.MATRIX(sum(A)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0, Types.AggOp.SUM, Types.Direction.RowCol);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule !=(A,t(colSums(A))) => !=(A,cast.MATRIX(sum(A)))
	private static Hop _applyRewrite431(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1_0 = (AggUnaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.AggOp.SUM || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,t(colSums(A))) => !=(A,cast.MATRIX(sum(A)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0, Types.AggOp.SUM, Types.Direction.RowCol);
		UnaryOp v2 = HopRewriteUtils.createUnary(v1, Types.OpOp1.CAST_AS_MATRIX);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0, v2, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule rev(!=(cast.MATRIX(a),b)) => !=(a,cast.MATRIX(b))
	private static Hop _applyRewrite432(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0_0 = (UnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(cast.MATRIX(a),b)) => !=(a,cast.MATRIX(b))");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_0_1, Types.OpOp1.CAST_AS_MATRIX);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(!=(a,cast.MATRIX(b))) => !=(a,cast.MATRIX(b))
	private static Hop _applyRewrite433(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof UnaryOp) )
			return hi;

		UnaryOp c_hi_0_1 = (UnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp1.CAST_AS_MATRIX || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(a,cast.MATRIX(b))) => !=(a,cast.MATRIX(b))");
		UnaryOp v1 = HopRewriteUtils.createUnary(hi_0_1_0, Types.OpOp1.CAST_AS_MATRIX);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule trace(-($1:colSums(A),b)) => -(trace(colSums(A)),b)
	private static Hop _applyRewrite434(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(-($1:colSums(A),b)) => -(trace(colSums(A)),b)");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(v2, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(-(a,$1:colSums(B))) => -(a,trace(colSums(B)))
	private static Hop _applyRewrite435(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(-(a,$1:colSums(B))) => -(a,trace(colSums(B)))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(hi_0_0, v2, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule trace(+($1:colSums(A),b)) => +(trace(colSums(A)),b)
	private static Hop _applyRewrite436(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+($1:colSums(A),b)) => +(trace(colSums(A)),b)");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(v2, hi_0_1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule trace(+(b,$1:colSums(A))) => +(trace(colSums(A)),b)
	private static Hop _applyRewrite437(Hop hi) {
		if ( !(hi instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi = (AggUnaryOp) hi;

		if ( c_hi.getOp() != Types.AggOp.SUM || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: trace(+(b,$1:colSums(A))) => +(trace(colSums(A)),b)");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		AggUnaryOp v2 = HopRewriteUtils.createAggUnaryOp(v1, Types.AggOp.TRACE, Types.Direction.RowCol);
		BinaryOp v3 = HopRewriteUtils.createBinary(v2, hi_0_0, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule !=(A,rev(rowSums(A))) => !=(A,rowSums(A))
	private static Hop _applyRewrite438(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1_0 = (AggUnaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.AggOp.SUM || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1_0.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(rowSums(A))) => !=(A,rowSums(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,rowSums(rev(A))) => !=(A,rowSums(A))
	private static Hop _applyRewrite439(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rowSums(rev(A))) => !=(A,rowSums(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0, Types.AggOp.SUM, Types.Direction.Row);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(A,colSums(rev(A))) => !=(A,colSums(A))
	private static Hop _applyRewrite440(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,colSums(rev(A))) => !=(A,colSums(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,colSums($1:rev(A))) => +(A,colSums(A))
	private static Hop _applyRewrite441(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,colSums($1:rev(A))) => +(A,colSums(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule *(A,colSums($1:rev(A))) => *(A,colSums(A))
	private static Hop _applyRewrite442(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(A,colSums($1:rev(A))) => *(A,colSums(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule %*%(*(a,C),*(b,D)) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite443(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_1.getDim2() == -1 || hi_1_1.getDim2() == -1 || hi_0_1.getNnz() == -1 || hi_0_1.getDim1() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_1.getNnz()) + (2.0 * hi_1_1.getNnz()) + (Math.min(hi_0_1.getNnz(), hi_1_1.getNnz()) * hi_0_1.getDim2() * 3.0) + 30030.0);
		double costTo = ((Math.min(hi_0_1.getNnz(), hi_1_1.getNnz()) * hi_0_1.getDim2() * 3.0) + (2.0 * (Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_0_1.getDim1() * hi_1_1.getDim2())) + 20032.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(a,C),*(b,D)) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_1, hi_1_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(*(a,C),*(D,b)) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite444(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_1.getDim2() == -1 || hi_0_1.getNnz() == -1 || hi_1_0.getDim2() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_1.getNnz()) + (2.0 * hi_1_0.getNnz()) + (Math.min(hi_0_1.getNnz(), hi_1_0.getNnz()) * hi_0_1.getDim2() * 3.0) + 30030.0);
		double costTo = ((Math.min(hi_0_1.getNnz(), hi_1_0.getNnz()) * hi_0_1.getDim2() * 3.0) + (2.0 * (Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim1())), 1.0) * Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim2())), 1.0) * hi_0_1.getDim1() * hi_1_0.getDim2())) + 20032.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(a,C),*(D,b)) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_1, hi_1_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(*(C,a),*(b,D)) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite445(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_1_1.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0.getNnz()) + (2.0 * hi_1_1.getNnz()) + (Math.min(hi_0_0.getNnz(), hi_1_1.getNnz()) * hi_0_0.getDim2() * 3.0) + 30030.0);
		double costTo = ((Math.min(hi_0_0.getNnz(), hi_1_1.getNnz()) * hi_0_0.getDim2() * 3.0) + (2.0 * (Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_0_0.getDim1() * hi_1_1.getDim2())) + 20032.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(C,a),*(b,D)) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0, hi_1_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(*(C,a),*(D,b)) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite446(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0.getNnz()) + (2.0 * hi_1_0.getNnz()) + (Math.min(hi_0_0.getNnz(), hi_1_0.getNnz()) * hi_0_0.getDim2() * 3.0) + 30030.0);
		double costTo = ((Math.min(hi_0_0.getNnz(), hi_1_0.getNnz()) * hi_0_0.getDim2() * 3.0) + (2.0 * (Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim2())), 1.0) * hi_0_0.getDim1() * hi_1_0.getDim2())) + 20032.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(C,a),*(D,b)) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_1, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0, hi_1_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule *(%*%($1:*(a,C),D),b) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite447(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(%*%($1:*(a,C),D),b) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0_1, hi_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(%*%($1:*(C,a),D),b) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite448(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(%*%($1:*(C,a),D),b) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_1, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0_0, hi_0_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(%*%(C,$1:*(D,a)),b) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite449(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(%*%(C,$1:*(D,a)),b) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_1, hi_1, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_0, hi_0_1_0);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule *(a,%*%($1:*(b,C),D)) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite450(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,%*%($1:*(b,C),D)) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_1_0_1, hi_1_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(a,%*%($1:*(C,b),D)) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite451(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,%*%($1:*(C,b),D)) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_1_0_0, hi_1_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(a,%*%(C,$1:*(b,D))) => *(*(a,b),%*%(C,D))
	private static Hop _applyRewrite452(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,%*%(C,$1:*(b,D))) => *(*(a,b),%*%(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.MULT);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_1_1_1);
		BinaryOp v3 = HopRewriteUtils.createBinary(v1, v2, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule %*%(/(a,C),*(b,D)) => %*%(/(*(a,b),C),D)
	private static Hop _applyRewrite453(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(/(a,C),*(b,D)) => %*%(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(v2, hi_1_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(/(a,C),*(D,b)) => %*%(/(*(a,b),C),D)
	private static Hop _applyRewrite454(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(/(a,C),*(D,b)) => %*%(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(v2, hi_1_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule *(%*%($1:/(a,C),D),b) => %*%(/(*(a,b),C),D)
	private static Hop _applyRewrite455(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(%*%($1:/(a,C),D),b) => %*%(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(v2, hi_0_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,%*%($1:/(b,C),D)) => %*%(/(*(a,b),C),D)
	private static Hop _applyRewrite456(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,%*%($1:/(b,C),D)) => %*%(/(*(a,b),C),D)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(v2, hi_1_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule %*%(*(b,A),/(c,D)) => %*%(A,/(*(b,c),D))
	private static Hop _applyRewrite457(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(b,A),/(c,D)) => %*%(A,/(*(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(hi_0_1, v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule %*%(*(A,b),/(c,D)) => %*%(A,/(*(b,c),D))
	private static Hop _applyRewrite458(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(*(A,b),/(c,D)) => %*%(A,/(*(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(hi_0_0, v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v3;
	}

	// Implementation of the rule *(%*%(A,$1:/(b,D)),c) => %*%(A,/(*(b,c),D))
	private static Hop _applyRewrite459(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.DIV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(%*%(A,$1:/(b,D)),c) => %*%(A,/(*(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(hi_0_0, v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v3;
	}

	// Implementation of the rule *(b,%*%(A,$1:/(c,D))) => %*%(A,/(*(b,c),D))
	private static Hop _applyRewrite460(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.DIV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(b,%*%(A,$1:/(c,D))) => %*%(A,/(*(b,c),D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1_1, Types.OpOp2.DIV);
		AggBinaryOp v3 = HopRewriteUtils.createMatrixMultiply(hi_1_0, v2);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v3;
	}

	// Implementation of the rule t(%*%($1:t(B),A)) => %*%(t(A),B)
	private static Hop _applyRewrite461(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_0_1.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 || hi_0_1.getNnz() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = (hi_0_0_0.getNnz() + (Math.min((hi_0_0_0.getDim2() * hi_0_0_0.getDim1()), hi_0_1.getNnz()) * hi_0_0_0.getDim1() * 3.0) + (Math.min(((hi_0_0_0.getDim2() * hi_0_0_0.getDim1()) * (1.0 / hi_0_0_0.getDim2())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0_0.getDim2() * hi_0_1.getDim2()) + 30030.0);
		double costTo = (hi_0_1.getNnz() + (Math.min((hi_0_1.getDim2() * hi_0_1.getDim1()), hi_0_0_0.getNnz()) * hi_0_0_0.getDim1() * 3.0) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(%*%($1:t(B),A)) => %*%(t(A),B)");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_1);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule t(%*%(B,$1:t(A))) => %*%(A,t(B))
	private static Hop _applyRewrite462(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.TRANS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_0_1_0.getDim1() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = (hi_0_1_0.getNnz() + (Math.min(hi_0_0.getNnz(), (hi_0_1_0.getDim2() * hi_0_1_0.getDim1())) * hi_0_0.getDim2() * 3.0) + (Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min(((hi_0_1_0.getDim2() * hi_0_1_0.getDim1()) * (1.0 / hi_0_1_0.getDim1())), 1.0) * hi_0_0.getDim1() * hi_0_1_0.getDim1()) + 30030.0);
		double costTo = (hi_0_0.getNnz() + (Math.min(hi_0_1_0.getNnz(), (hi_0_0.getDim2() * hi_0_0.getDim1())) * hi_0_0.getDim2() * 3.0) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: t(%*%(B,$1:t(A))) => %*%(A,t(B))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0_1_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule %*%(t(B),t(A)) => t(%*%(A,B))
	private static Hop _applyRewrite463(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_0_0.getDim1() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 )
			return hi;


		double costFrom = (hi_0_0.getNnz() + hi_1_0.getNnz() + (Math.min((hi_0_0.getDim2() * hi_0_0.getDim1()), (hi_1_0.getDim2() * hi_1_0.getDim1())) * hi_1_0.getDim2() * 3.0) + 30030.0);
		double costTo = ((Math.min(hi_1_0.getNnz(), hi_0_0.getNnz()) * hi_1_0.getDim2() * 3.0) + (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim2())), 1.0) * hi_1_0.getDim1() * hi_0_0.getDim2()) + 20020.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(t(B),t(A)) => t(%*%(A,B))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_0_0);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule !=(%*%(B,rev(A)),A) => !=(A,%*%(B,A))
	private static Hop _applyRewrite464(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(%*%(B,rev(A)),A) => !=(A,%*%(B,A))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0, hi_0_1_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule !=(A,%*%(B,rev(A))) => !=(A,%*%(B,A))
	private static Hop _applyRewrite465(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,%*%(B,rev(A))) => !=(A,%*%(B,A))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_0);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule !=(rev(%*%(A,C)),A) => !=(A,%*%(A,C))
	private static Hop _applyRewrite466(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0_0) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(rev(%*%(A,C)),A) => !=(A,%*%(A,C))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0_0, hi_0_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,rev(%*%(A,C))) => !=(A,%*%(A,C))
	private static Hop _applyRewrite467(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1_0) )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,rev(%*%(A,C))) => !=(A,%*%(A,C))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0, hi_1_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule !=(%*%(rev(A),C),A) => !=(A,%*%(A,C))
	private static Hop _applyRewrite468(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(%*%(rev(A),C),A) => !=(A,%*%(A,C))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0_0, hi_0_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule !=(A,%*%(rev(A),C)) => !=(A,%*%(A,C))
	private static Hop _applyRewrite469(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.NOTEQUAL || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: !=(A,%*%(rev(A),C)) => !=(A,%*%(A,C))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0, hi_1_1);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule rev(%*%($1:!=(b,A),A)) => %*%(!=(A,b),A)
	private static Hop _applyRewrite470(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_0_1 != hi_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(%*%($1:!=(b,A),A)) => %*%(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(%*%($1:!=(A,b),A)) => %*%(!=(A,b),A)
	private static Hop _applyRewrite471(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_0_0 != hi_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(%*%($1:!=(A,b),A)) => %*%(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule %*%(!=(rev(A),b),A) => %*%(!=(A,b),A)
	private static Hop _applyRewrite472(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(!=(rev(A),b),A) => %*%(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule %*%(!=(b,rev(A)),A) => %*%(!=(A,b),A)
	private static Hop _applyRewrite473(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(!=(b,rev(A)),A) => %*%(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_1_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule %*%(rev($1:!=(b,A)),A) => %*%(!=(A,b),A)
	private static Hop _applyRewrite474(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_1 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(rev($1:!=(b,A)),A) => %*%(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_0_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule %*%(rev($1:!=(A,b)),A) => %*%(!=(A,b),A)
	private static Hop _applyRewrite475(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(rev($1:!=(A,b)),A) => %*%(!=(A,b),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_0_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule %*%(!=(rev(A),B),A) => %*%(!=(A,B),A)
	private static Hop _applyRewrite476(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_0 = (ReorgOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.ReOrgOp.REV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_0_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(!=(rev(A),B),A) => %*%(!=(A,B),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_0_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule %*%(!=(B,rev(A)),A) => %*%(!=(A,B),A)
	private static Hop _applyRewrite477(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0_1 = (ReorgOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.ReOrgOp.REV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_0_1_0 != hi_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(!=(B,rev(A)),A) => %*%(!=(A,B),A)");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1_0, hi_0_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_1_0);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule %*%(A,!=(rev(A),c)) => %*%(A,!=(A,c))
	private static Hop _applyRewrite478(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(A,!=(rev(A),c)) => %*%(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule %*%(A,!=(c,rev(A))) => %*%(A,!=(A,c))
	private static Hop _applyRewrite479(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(A,!=(c,rev(A))) => %*%(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule %*%(A,rev($1:!=(c,A))) => %*%(A,!=(A,c))
	private static Hop _applyRewrite480(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_0 != hi_1_0_1 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(A,rev($1:!=(c,A))) => %*%(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule %*%(A,rev($1:!=(A,c))) => %*%(A,!=(A,c))
	private static Hop _applyRewrite481(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(A,rev($1:!=(A,c))) => %*%(A,!=(A,c))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule %*%(A,!=(rev(A),C)) => %*%(A,!=(A,C))
	private static Hop _applyRewrite482(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_0 = (ReorgOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.ReOrgOp.REV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_0 != hi_1_0_0 )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(A,!=(rev(A),C)) => %*%(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_1, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule %*%(A,!=(C,rev(A))) => %*%(A,!=(A,C))
	private static Hop _applyRewrite483(Hop hi) {
		if ( !HopRewriteUtils.isMatrixMultiply(hi) )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1_1 = (ReorgOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.ReOrgOp.REV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_0 != hi_1_1_0 )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: %*%(A,!=(C,rev(A))) => %*%(A,!=(A,C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0, Types.OpOp2.NOTEQUAL);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(hi_0, v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule rev(-($1:colSums(A),b)) => -(colSums(A),b)
	private static Hop _applyRewrite484(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(-($1:colSums(A),b)) => -(colSums(A),b)");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(-(a,$1:colSums(B))) => -(a,colSums(B))
	private static Hop _applyRewrite485(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(-(a,$1:colSums(B))) => -(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule rev(!=(colSums(B),a)) => !=(a,colSums(B))
	private static Hop _applyRewrite486(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(colSums(B),a)) => !=(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(!=(a,colSums(B))) => !=(a,colSums(B))
	private static Hop _applyRewrite487(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.NOTEQUAL || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(!=(a,colSums(B))) => !=(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.NOTEQUAL);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule rev(t($1:rowSums(A))) => t(rowSums(A))
	private static Hop _applyRewrite488(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(t($1:rowSums(A))) => t(rowSums(A))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Row);
		ReorgOp v2 = HopRewriteUtils.createTranspose(v1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(+($1:colSums(B),a)) => +(a,colSums(B))
	private static Hop _applyRewrite489(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(+($1:colSums(B),a)) => +(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(+(a,$1:colSums(B))) => +(a,colSums(B))
	private static Hop _applyRewrite490(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(+(a,$1:colSums(B))) => +(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule rev(*($1:colSums(B),a)) => *(a,colSums(B))
	private static Hop _applyRewrite491(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(*($1:colSums(B),a)) => *(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule rev(*(a,$1:colSums(B))) => *(a,colSums(B))
	private static Hop _applyRewrite492(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(*(a,$1:colSums(B))) => *(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule rev(/(a,colSums(B))) => /(a,colSums(B))
	private static Hop _applyRewrite493(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_1 = (AggUnaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.AggOp.SUM || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(/(a,colSums(B))) => /(a,colSums(B))");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_1_0, Types.AggOp.SUM, Types.Direction.Col);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.DIV);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule *(colSums($1:/(a,C)),b) => colSums(/(*(a,b),C))
	private static Hop _applyRewrite494(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0 = (AggUnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.AggOp.SUM || !c_hi_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(colSums($1:/(a,C)),b) => colSums(/(*(a,b),C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_1, Types.OpOp2.DIV);
		AggUnaryOp v3 = HopRewriteUtils.createAggUnaryOp(v2, Types.AggOp.SUM, Types.Direction.Col);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,colSums($1:/(b,C))) => colSums(/(*(a,b),C))
	private static Hop _applyRewrite495(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,colSums($1:/(b,C))) => colSums(/(*(a,b),C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_1, Types.OpOp2.DIV);
		AggUnaryOp v3 = HopRewriteUtils.createAggUnaryOp(v2, Types.AggOp.SUM, Types.Direction.Col);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule *(rowSums($1:/(a,C)),b) => rowSums(/(*(a,b),C))
	private static Hop _applyRewrite496(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0 = (AggUnaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.AggOp.SUM || !c_hi_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(rowSums($1:/(a,C)),b) => rowSums(/(*(a,b),C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_1, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_0_1, Types.OpOp2.DIV);
		AggUnaryOp v3 = HopRewriteUtils.createAggUnaryOp(v2, Types.AggOp.SUM, Types.Direction.Row);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v3;
	}

	// Implementation of the rule *(a,rowSums($1:/(b,C))) => rowSums(/(*(a,b),C))
	private static Hop _applyRewrite497(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MULT || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_1 = (AggUnaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.AggOp.SUM || !c_hi_1.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_1.getDirection() == Types.Direction.Row) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: *(a,rowSums($1:/(b,C))) => rowSums(/(*(a,b),C))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0, hi_1_0_0, Types.OpOp2.MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0_1, Types.OpOp2.DIV);
		AggUnaryOp v3 = HopRewriteUtils.createAggUnaryOp(v2, Types.AggOp.SUM, Types.Direction.Row);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v3);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v3;
	}

	// Implementation of the rule rev(%*%($1:colSums(A),B)) => %*%(colSums(A),B)
	private static Hop _applyRewrite498(Hop hi) {
		if ( !(hi instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi = (ReorgOp) hi;

		if ( c_hi.getOp() != Types.ReOrgOp.REV || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof AggUnaryOp) )
			return hi;

		AggUnaryOp c_hi_0_0 = (AggUnaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.AggOp.SUM || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		if ( !(c_hi_0_0.getDirection() == Types.Direction.Col) )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: rev(%*%($1:colSums(A),B)) => %*%(colSums(A),B)");
		AggUnaryOp v1 = HopRewriteUtils.createAggUnaryOp(hi_0_0_0, Types.AggOp.SUM, Types.Direction.Col);
		AggBinaryOp v2 = HopRewriteUtils.createMatrixMultiply(v1, hi_0_1);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule -(A,rev($1:*(b,C))) => -*(A,b,rev(C))
	private static Hop _applyRewrite499(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_1.getDim1() == -1 || hi_1_0_1.getDim2() == -1 || hi_1_0_1.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_1.getNnz()) + hi_1_0_1.getNnz() + (hi_0.getNnz() + (hi_1_0_1.getDim1() * hi_1_0_1.getDim2())) + 30030.0);
		double costTo = (hi_1_0_1.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_1.getDim1() * hi_1_0_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,rev($1:*(b,C))) => -*(A,b,rev(C))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_1_0_1, Types.ReOrgOp.REV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,rev($1:*(C,b))) => -*(A,b,rev(C))
	private static Hop _applyRewrite500(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_0.getDim2() == -1 || hi_1_0_0.getDim1() == -1 || hi_1_0_0.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_0.getNnz()) + hi_1_0_0.getNnz() + (hi_0.getNnz() + (hi_1_0_0.getDim1() * hi_1_0_0.getDim2())) + 30030.0);
		double costTo = (hi_1_0_0.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_0.getDim1() * hi_1_0_0.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,rev($1:*(C,b))) => -*(A,b,rev(C))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,t($1:*(b,C))) => -*(A,b,t(C))
	private static Hop _applyRewrite501(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_1.getDim1() == -1 || hi_1_0_1.getDim2() == -1 || hi_1_0_1.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_1.getNnz()) + hi_1_0_1.getNnz() + (hi_0.getNnz() + (hi_1_0_1.getDim2() * hi_1_0_1.getDim1())) + 30030.0);
		double costTo = (hi_1_0_1.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_1.getDim2() * hi_1_0_1.getDim1()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,t($1:*(b,C))) => -*(A,b,t(C))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_1_0_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,t($1:*(C,b))) => -*(A,b,t(C))
	private static Hop _applyRewrite502(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_0.getDim2() == -1 || hi_1_0_0.getDim1() == -1 || hi_1_0_0.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_0.getNnz()) + hi_1_0_0.getNnz() + (hi_0.getNnz() + (hi_1_0_0.getDim2() * hi_1_0_0.getDim1())) + 30030.0);
		double costTo = (hi_1_0_0.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_0.getDim2() * hi_1_0_0.getDim1()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,t($1:*(C,b))) => -*(A,b,t(C))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_1_0_0);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(rev($1:*(b,C)),A) => +*(A,b,rev(C))
	private static Hop _applyRewrite503(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim2() == -1 || hi_1.getNnz() == -1 || hi_0_0_1.getDim1() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + hi_0_0_1.getNnz() + ((hi_0_0_1.getDim1() * hi_0_0_1.getDim2()) + hi_1.getNnz()) + 30030.0);
		double costTo = (hi_0_0_1.getNnz() + (3.0 * Math.min(hi_1.getNnz(), (hi_0_0_1.getDim1() * hi_0_0_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:*(b,C)),A) => +*(A,b,rev(C))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_1, Types.ReOrgOp.REV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(rev($1:*(C,b)),A) => +*(A,b,rev(C))
	private static Hop _applyRewrite504(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.REV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_1.getNnz() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + hi_0_0_0.getNnz() + ((hi_0_0_0.getDim1() * hi_0_0_0.getDim2()) + hi_1.getNnz()) + 30030.0);
		double costTo = (hi_0_0_0.getNnz() + (3.0 * Math.min(hi_1.getNnz(), (hi_0_0_0.getDim1() * hi_0_0_0.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(rev($1:*(C,b)),A) => +*(A,b,rev(C))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_0_0_0, Types.ReOrgOp.REV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(A,rev($1:*(C,b))) => +*(A,b,rev(C))
	private static Hop _applyRewrite505(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.REV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_0.getDim2() == -1 || hi_1_0_0.getDim1() == -1 || hi_1_0_0.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_0.getNnz()) + hi_1_0_0.getNnz() + (hi_0.getNnz() + (hi_1_0_0.getDim1() * hi_1_0_0.getDim2())) + 30030.0);
		double costTo = (hi_1_0_0.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_0.getDim1() * hi_1_0_0.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,rev($1:*(C,b))) => +*(A,b,rev(C))");
		ReorgOp v1 = HopRewriteUtils.createReorg(hi_1_0_0, Types.ReOrgOp.REV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(-(a,$1:*(c,D)),B) => -(a,+*(B,c,D))
	private static Hop _applyRewrite506(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(a,$1:*(c,D)),B) => -(a,+*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_1_0, hi_0_1_1,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule -(-(a,$1:*(D,c)),B) => -(a,+*(B,c,D))
	private static Hop _applyRewrite507(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(-(a,$1:*(D,c)),B) => -(a,+*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_1_1, hi_0_1_0,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule -(A,+($1:*(b,C),d)) => -(-*(A,b,C),d)
	private static Hop _applyRewrite508(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,+($1:*(b,C),d)) => -(-*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, hi_1_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,+($1:*(C,b),d)) => -(-*(A,b,C),d)
	private static Hop _applyRewrite509(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,+($1:*(C,b),d)) => -(-*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, hi_1_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,+(d,$1:*(b,C))) => -(-*(A,b,C),d)
	private static Hop _applyRewrite510(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,+(d,$1:*(b,C))) => -(-*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, hi_1_1_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(A,+(d,$1:*(C,b))) => -(-*(A,b,C),d)
	private static Hop _applyRewrite511(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.PLUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,+(d,$1:*(C,b))) => -(-*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_1_1, hi_1_1_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule +(t($1:*(b,C)),A) => +*(A,b,t(C))
	private static Hop _applyRewrite512(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim2() == -1 || hi_1.getNnz() == -1 || hi_0_0_1.getDim1() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + hi_0_0_1.getNnz() + ((hi_0_0_1.getDim2() * hi_0_0_1.getDim1()) + hi_1.getNnz()) + 30030.0);
		double costTo = (hi_0_0_1.getNnz() + (3.0 * Math.min(hi_1.getNnz(), (hi_0_0_1.getDim2() * hi_0_0_1.getDim1()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t($1:*(b,C)),A) => +*(A,b,t(C))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(t($1:*(C,b)),A) => +*(A,b,t(C))
	private static Hop _applyRewrite513(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_0 = (ReorgOp) hi_0;

		if ( c_hi_0.getOp() != Types.ReOrgOp.TRANS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_0.getDim2() == -1 || hi_1.getNnz() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_0_0.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + hi_0_0_0.getNnz() + ((hi_0_0_0.getDim2() * hi_0_0_0.getDim1()) + hi_1.getNnz()) + 30030.0);
		double costTo = (hi_0_0_0.getNnz() + (3.0 * Math.min(hi_1.getNnz(), (hi_0_0_0.getDim2() * hi_0_0_0.getDim1()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(t($1:*(C,b)),A) => +*(A,b,t(C))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_0_0_0);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(A,t($1:*(b,C))) => +*(A,b,t(C))
	private static Hop _applyRewrite514(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_1.getDim1() == -1 || hi_1_0_1.getDim2() == -1 || hi_1_0_1.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_1.getNnz()) + hi_1_0_1.getNnz() + (hi_0.getNnz() + (hi_1_0_1.getDim2() * hi_1_0_1.getDim1())) + 30030.0);
		double costTo = (hi_1_0_1.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_1.getDim2() * hi_1_0_1.getDim1()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,t($1:*(b,C))) => +*(A,b,t(C))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_1_0_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,t($1:*(C,b))) => +*(A,b,t(C))
	private static Hop _applyRewrite515(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof ReorgOp) )
			return hi;

		ReorgOp c_hi_1 = (ReorgOp) hi_1;

		if ( c_hi_1.getOp() != Types.ReOrgOp.TRANS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_0.getDim2() == -1 || hi_1_0_0.getDim1() == -1 || hi_1_0_0.getNnz() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_0.getNnz()) + hi_1_0_0.getNnz() + (hi_0.getNnz() + (hi_1_0_0.getDim2() * hi_1_0_0.getDim1())) + 30030.0);
		double costTo = (hi_1_0_0.getNnz() + (3.0 * Math.min(hi_0.getNnz(), (hi_1_0_0.getDim2() * hi_1_0_0.getDim1()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,t($1:*(C,b))) => +*(A,b,t(C))");
		ReorgOp v1 = HopRewriteUtils.createTranspose(hi_1_0_0);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(+($1:*(c,D),a),B) => -(a,-*(B,c,D))
	private static Hop _applyRewrite516(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+($1:*(c,D),a),B) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, hi_0_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule -(+($1:*(D,c),a),B) => -(a,-*(B,c,D))
	private static Hop _applyRewrite517(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+($1:*(D,c),a),B) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_0_1, hi_0_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule -(+(a,$1:*(c,D)),B) => -(a,-*(B,c,D))
	private static Hop _applyRewrite518(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(a,$1:*(c,D)),B) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_1_0, hi_0_1_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule -(+(a,$1:*(D,c)),B) => -(a,-*(B,c,D))
	private static Hop _applyRewrite519(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.PLUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(+(a,$1:*(D,c)),B) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_1_1, hi_0_1_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule -(*(c,D),-(B,a)) => -(a,-*(B,c,D))
	private static Hop _applyRewrite520(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(*(c,D),-(B,a)) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_0, hi_0_0, hi_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(*(D,c),-(B,a)) => -(a,-*(B,c,D))
	private static Hop _applyRewrite521(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(*(D,c),-(B,a)) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_0, hi_0_1, hi_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(-($1:*(c,D),B),a) => -(a,-*(B,c,D))
	private static Hop _applyRewrite522(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:*(c,D),B),a) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0_1, hi_0_0_0, hi_0_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(-($1:*(D,c),B),a) => -(a,-*(B,c,D))
	private static Hop _applyRewrite523(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.SCALAR || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:*(D,c),B),a) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0_1, hi_0_0_1, hi_0_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(a,-($1:*(c,D),B)) => -(a,-*(B,c,D))
	private static Hop _applyRewrite524(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,-($1:*(c,D),B)) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_1_0_0, hi_1_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(a,-($1:*(D,c),B)) => -(a,-*(B,c,D))
	private static Hop _applyRewrite525(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(a,-($1:*(D,c),B)) => -(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_1_0_1, hi_1_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,-(d,$1:*(b,C))) => -(+*(A,b,C),d)
	private static Hop _applyRewrite526(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,-(d,$1:*(b,C))) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, hi_1_1_1,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(A,-(d,$1:*(C,b))) => -(+*(A,b,C),d)
	private static Hop _applyRewrite527(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,-(d,$1:*(C,b))) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_1_1, hi_1_1_0,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(*(b,C),-(d,A)) => -(+*(A,b,C),d)
	private static Hop _applyRewrite528(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(*(b,C),-(d,A)) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_0_0, hi_0_1,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(*(C,b),-(d,A)) => -(+*(A,b,C),d)
	private static Hop _applyRewrite529(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(*(C,b),-(d,A)) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_0_1, hi_0_0,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_0, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(-($1:*(b,C),d),A) => -(+*(A,b,C),d)
	private static Hop _applyRewrite530(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:*(b,C),d),A) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, hi_0_0_1,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(-($1:*(C,b),d),A) => -(+*(A,b,C),d)
	private static Hop _applyRewrite531(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:*(C,b),d),A) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_0_1, hi_0_0_0,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_0_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(A,-($1:*(b,C),d)) => -(+*(A,b,C),d)
	private static Hop _applyRewrite532(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,-($1:*(b,C),d)) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, hi_1_0_1,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,-($1:*(C,b),d)) => -(+*(A,b,C),d)
	private static Hop _applyRewrite533(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,-($1:*(C,b),d)) => -(+*(A,b,C),d)");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, hi_1_0_0,Types.OpOp3.PLUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(v1, hi_1_1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(a,-($1:*(c,D),B)) => +(a,-*(B,c,D))
	private static Hop _applyRewrite534(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,-($1:*(c,D),B)) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_1_0_0, hi_1_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(a,-($1:*(D,c),B)) => +(a,-*(B,c,D))
	private static Hop _applyRewrite535(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.SCALAR || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(a,-($1:*(D,c),B)) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_1_0_1, hi_1_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(B,-($1:*(c,D),a)) => +(a,-*(B,c,D))
	private static Hop _applyRewrite536(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(B,-($1:*(c,D),a)) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, hi_1_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(B,-($1:*(D,c),a)) => +(a,-*(B,c,D))
	private static Hop _applyRewrite537(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(B,-($1:*(D,c),a)) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, hi_1_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(-(a,$1:*(c,D)),B) => +(a,-*(B,c,D))
	private static Hop _applyRewrite538(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(a,$1:*(c,D)),B) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_1_0, hi_0_1_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(-(a,$1:*(D,c)),B) => +(a,-*(B,c,D))
	private static Hop _applyRewrite539(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-(a,$1:*(D,c)),B) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1, hi_0_1_1, hi_0_1_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(B,-(a,$1:*(c,D))) => +(a,-*(B,c,D))
	private static Hop _applyRewrite540(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(B,-(a,$1:*(c,D))) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, hi_1_1_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule +(B,-(a,$1:*(D,c))) => +(a,-*(B,c,D))
	private static Hop _applyRewrite541(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(B,-(a,$1:*(D,c))) => +(a,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_1_1, hi_1_1_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_0, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(B,-($1:*(c,D),A)) => +(A,-*(B,c,D))
	private static Hop _applyRewrite542(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(B,-($1:*(c,D),A)) => +(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, hi_1_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(B,-($1:*(D,c),A)) => +(A,-*(B,c,D))
	private static Hop _applyRewrite543(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(B,-($1:*(D,c),A)) => +(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, hi_1_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.PLUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(*(c,D),-(B,A)) => -(A,-*(B,c,D))
	private static Hop _applyRewrite544(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(*(c,D),-(B,A)) => -(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_0, hi_0_0, hi_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule -(*(D,c),-(B,A)) => -(A,-*(B,c,D))
	private static Hop _applyRewrite545(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(*(D,c),-(B,A)) => -(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_0, hi_0_1, hi_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_1);

		return v2;
	}

	// Implementation of the rule +(-($1:*(c,D),B),A) => -(A,-*(B,c,D))
	private static Hop _applyRewrite546(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:*(c,D),B),A) => -(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0_1, hi_0_0_0, hi_0_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(-($1:*(D,c),B),A) => -(A,-*(B,c,D))
	private static Hop _applyRewrite547(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MINUS || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(-($1:*(D,c),B),A) => -(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_0_1, hi_0_0_1, hi_0_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_1, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(A,-($1:*(c,D),B)) => -(A,-*(B,c,D))
	private static Hop _applyRewrite548(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,-($1:*(c,D),B)) => -(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_1_0_0, hi_1_0_1,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,-($1:*(D,c),B)) => -(A,-*(B,c,D))
	private static Hop _applyRewrite549(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MINUS || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,-($1:*(D,c),B)) => -(A,-*(B,c,D))");
		TernaryOp v1 = HopRewriteUtils.createTernary(hi_1_1, hi_1_0_1, hi_1_0_0,Types.OpOp3.MINUS_MULT);
		BinaryOp v2 = HopRewriteUtils.createBinary(hi_0, v1, Types.OpOp2.MINUS);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,*($1:/(b,D),C)) => -*(A,b,/(C,D))
	private static Hop _applyRewrite550(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,*($1:/(b,D),C)) => -*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,*(C,$1:/(b,D))) => -*(A,b,/(C,D))
	private static Hop _applyRewrite551(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.DIV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,*(C,$1:/(b,D))) => -*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_1_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(A,/($1:*(b,C),D)) => -*(A,b,/(C,D))
	private static Hop _applyRewrite552(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,/($1:*(b,C),D)) => -*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0_1, hi_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,/($1:*(C,b),D)) => -*(A,b,/(C,D))
	private static Hop _applyRewrite553(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,/($1:*(C,b),D)) => -*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0_0, hi_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(*($1:/(b,D),C),A) => +*(A,b,/(C,D))
	private static Hop _applyRewrite554(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.DIV || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(*($1:/(b,D),C),A) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_1, hi_0_0_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(/($1:*(b,C),D),A) => +*(A,b,/(C,D))
	private static Hop _applyRewrite555(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(/($1:*(b,C),D),A) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_1, hi_0_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(/($1:*(C,b),D),A) => +*(A,b,/(C,D))
	private static Hop _applyRewrite556(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.DIV || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(/($1:*(C,b),D),A) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0_0, hi_0_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(*(C,$1:/(b,D)),A) => +*(A,b,/(C,D))
	private static Hop _applyRewrite557(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0 = (BinaryOp) hi_0;

		if ( c_hi_0.getOp() != Types.OpOp2.MULT || !c_hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.DIV || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(*(C,$1:/(b,D)),A) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_0_0, hi_0_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_1_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(A,/($1:*(b,C),D)) => +*(A,b,/(C,D))
	private static Hop _applyRewrite558(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,/($1:*(b,C),D)) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0_1, hi_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,*($1:/(b,D),C)) => +*(A,b,/(C,D))
	private static Hop _applyRewrite559(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.DIV || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,*($1:/(b,D),C)) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_1, hi_1_0_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,/($1:*(C,b),D)) => +*(A,b,/(C,D))
	private static Hop _applyRewrite560(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.DIV || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,/($1:*(C,b),D)) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0_0, hi_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,*(C,$1:/(b,D))) => +*(A,b,/(C,D))
	private static Hop _applyRewrite561(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1 = (BinaryOp) hi_1;

		if ( c_hi_1.getOp() != Types.OpOp2.MULT || !c_hi_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.DIV || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,*(C,$1:/(b,D))) => +*(A,b,/(C,D))");
		BinaryOp v1 = HopRewriteUtils.createBinary(hi_1_0, hi_1_1_1, Types.OpOp2.DIV);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(A,%*%($1:*(b,C),D)) => -*(A,b,%*%(C,D))
	private static Hop _applyRewrite562(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_1.getDim1() == -1 || hi_1_1.getDim2() == -1 || hi_1_0_1.getDim2() == -1 || hi_1_0_1.getNnz() == -1 || hi_0.getNnz() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_1.getNnz()) + (Math.min(hi_1_0_1.getNnz(), hi_1_1.getNnz()) * hi_1_0_1.getDim2() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0_1.getNnz() * (1.0 / hi_1_0_1.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_1.getDim1() * hi_1_1.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0_1.getNnz(), hi_1_1.getNnz()) * hi_1_0_1.getDim2() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0_1.getNnz() * (1.0 / hi_1_0_1.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_1.getDim1() * hi_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,%*%($1:*(b,C),D)) => -*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0_1, hi_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,%*%($1:*(C,b),D)) => -*(A,b,%*%(C,D))
	private static Hop _applyRewrite563(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_0.getDim2() == -1 || hi_1_0_0.getDim1() == -1 || hi_1_1.getDim2() == -1 || hi_1_0_0.getNnz() == -1 || hi_0.getNnz() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_0.getNnz()) + (Math.min(hi_1_0_0.getNnz(), hi_1_1.getNnz()) * hi_1_0_0.getDim2() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0_0.getNnz() * (1.0 / hi_1_0_0.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_0.getDim1() * hi_1_1.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0_0.getNnz(), hi_1_1.getNnz()) * hi_1_0_0.getDim2() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0_0.getNnz() * (1.0 / hi_1_0_0.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_0.getDim1() * hi_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,%*%($1:*(C,b),D)) => -*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0_0, hi_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule -(A,%*%(C,$1:*(b,D))) => -*(A,b,%*%(C,D))
	private static Hop _applyRewrite564(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_1_1_1.getNnz() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_1_1_1.getDim2() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_1_1.getNnz()) + (Math.min(hi_1_0.getNnz(), hi_1_1_1.getNnz()) * hi_1_0.getDim2() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_1.getNnz() * (1.0 / hi_1_1_1.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_1.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0.getNnz(), hi_1_1_1.getNnz()) * hi_1_0.getDim2() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_1.getNnz() * (1.0 / hi_1_1_1.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,%*%(C,$1:*(b,D))) => -*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_1_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule -(A,%*%(C,$1:*(D,b))) => -*(A,b,%*%(C,D))
	private static Hop _applyRewrite565(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.MINUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_0.getNnz() == -1 || hi_1_1_0.getNnz() == -1 || hi_1_1_0.getDim2() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_1_0.getNnz()) + (Math.min(hi_1_0.getNnz(), hi_1_1_0.getNnz()) * hi_1_0.getDim2() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_0.getNnz() * (1.0 / hi_1_1_0.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_0.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0.getNnz(), hi_1_1_0.getNnz()) * hi_1_0.getDim2() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_0.getNnz() * (1.0 / hi_1_1_0.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_0.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: -(A,%*%(C,$1:*(D,b))) => -*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_1_1_0);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_1_1, v1,Types.OpOp3.MINUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule +(%*%($1:*(b,C),D),A) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite566(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.SCALAR || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0_1.getDim2() == -1 || hi_1.getNnz() == -1 || hi_0_1.getDim2() == -1 || hi_0_0_1.getDim1() == -1 || hi_0_1.getNnz() == -1 || hi_0_0_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_1.getNnz()) + (Math.min(hi_0_0_1.getNnz(), hi_0_1.getNnz()) * hi_0_0_1.getDim2() * 3.0) + ((Math.min((hi_0_0_1.getNnz() * (1.0 / hi_0_0_1.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0_1.getDim1() * hi_0_1.getDim2()) + hi_1.getNnz()) + 30030.0);
		double costTo = ((Math.min(hi_0_0_1.getNnz(), hi_0_1.getNnz()) * hi_0_0_1.getDim2() * 3.0) + (3.0 * Math.min(hi_1.getNnz(), (Math.min((hi_0_0_1.getNnz() * (1.0 / hi_0_0_1.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0_1.getDim1() * hi_0_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(%*%($1:*(b,C),D),A) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0_1, hi_0_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(%*%($1:*(C,b),D),A) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite567(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if (hi_0_0.getParent().size() > 1)
			return hi;
		if ( !(hi_0_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_0 = (BinaryOp) hi_0_0;

		if ( c_hi_0_0.getOp() != Types.OpOp2.MULT || !c_hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_0 = hi_0_0.getInput(0);

		if ( hi_0_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_0_1 = hi_0_0.getInput(1);

		if ( hi_0_0_1.getDataType() != Types.DataType.SCALAR || !hi_0_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if ( hi_0_1.getDataType() != Types.DataType.MATRIX || !hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1.getNnz() == -1 || hi_0_1.getDim2() == -1 || hi_0_0_0.getNnz() == -1 || hi_0_1.getNnz() == -1 || hi_0_0_0.getDim1() == -1 || hi_0_1.getDim1() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_0_0.getNnz()) + (Math.min(hi_0_0_0.getNnz(), hi_0_1.getNnz()) * hi_0_1.getDim1() * 3.0) + ((Math.min((hi_0_0_0.getNnz() * (1.0 / hi_0_0_0.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0_0.getDim1() * hi_0_1.getDim2()) + hi_1.getNnz()) + 30030.0);
		double costTo = ((Math.min(hi_0_0_0.getNnz(), hi_0_1.getNnz()) * hi_0_1.getDim1() * 3.0) + (3.0 * Math.min(hi_1.getNnz(), (Math.min((hi_0_0_0.getNnz() * (1.0 / hi_0_0_0.getDim1())), 1.0) * Math.min((hi_0_1.getNnz() * (1.0 / hi_0_1.getDim2())), 1.0) * hi_0_0_0.getDim1() * hi_0_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(%*%($1:*(C,b),D),A) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0_0, hi_0_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_0);

		return v2;
	}

	// Implementation of the rule +(%*%(C,$1:*(b,D)),A) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite568(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.SCALAR || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.MATRIX || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_1.getNnz() == -1 || hi_0_1_1.getNnz() == -1 || hi_0_1_1.getDim2() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_1_1.getNnz()) + (Math.min(hi_0_0.getNnz(), hi_0_1_1.getNnz()) * hi_0_0.getDim2() * 3.0) + ((Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_0_1_1.getNnz() * (1.0 / hi_0_1_1.getDim2())), 1.0) * hi_0_0.getDim1() * hi_0_1_1.getDim2()) + hi_1.getNnz()) + 30030.0);
		double costTo = ((Math.min(hi_0_0.getNnz(), hi_0_1_1.getNnz()) * hi_0_0.getDim2() * 3.0) + (3.0 * Math.min(hi_1.getNnz(), (Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_0_1_1.getNnz() * (1.0 / hi_0_1_1.getDim2())), 1.0) * hi_0_0.getDim1() * hi_0_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(%*%(C,$1:*(b,D)),A) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0, hi_0_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_1_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(%*%(C,$1:*(D,b)),A) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite569(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if (hi_0.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_0) )
			return hi;

		Hop hi_0_0 = hi_0.getInput(0);

		if ( hi_0_0.getDataType() != Types.DataType.MATRIX || !hi_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1 = hi_0.getInput(1);

		if (hi_0_1.getParent().size() > 1)
			return hi;
		if ( !(hi_0_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_0_1 = (BinaryOp) hi_0_1;

		if ( c_hi_0_1.getOp() != Types.OpOp2.MULT || !c_hi_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_0 = hi_0_1.getInput(0);

		if ( hi_0_1_0.getDataType() != Types.DataType.MATRIX || !hi_0_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_0_1_1 = hi_0_1.getInput(1);

		if ( hi_0_1_1.getDataType() != Types.DataType.SCALAR || !hi_0_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if ( hi_1.getDataType() != Types.DataType.MATRIX || !hi_1.getValueType().isNumeric() )
			return hi;


		if ( hi_0_0.getDim1() == -1 || hi_1.getNnz() == -1 || hi_0_0.getNnz() == -1 || hi_0_0.getDim2() == -1 || hi_0_1_0.getDim2() == -1 || hi_0_1_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_0_1_0.getNnz()) + (Math.min(hi_0_0.getNnz(), hi_0_1_0.getNnz()) * hi_0_0.getDim2() * 3.0) + ((Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_0_1_0.getNnz() * (1.0 / hi_0_1_0.getDim2())), 1.0) * hi_0_0.getDim1() * hi_0_1_0.getDim2()) + hi_1.getNnz()) + 30030.0);
		double costTo = ((Math.min(hi_0_0.getNnz(), hi_0_1_0.getNnz()) * hi_0_0.getDim2() * 3.0) + (3.0 * Math.min(hi_1.getNnz(), (Math.min((hi_0_0.getNnz() * (1.0 / hi_0_0.getDim1())), 1.0) * Math.min((hi_0_1_0.getNnz() * (1.0 / hi_0_1_0.getDim2())), 1.0) * hi_0_0.getDim1() * hi_0_1_0.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(%*%(C,$1:*(D,b)),A) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_0_0, hi_0_1_0);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_1, hi_0_1_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_0);
		HopRewriteUtils.cleanupUnreferenced(hi_0_1);

		return v2;
	}

	// Implementation of the rule +(A,%*%($1:*(b,C),D)) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite570(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.SCALAR || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.MATRIX || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_1.getDim1() == -1 || hi_1_1.getDim2() == -1 || hi_1_0_1.getNnz() == -1 || hi_1_1.getDim1() == -1 || hi_0.getNnz() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_1.getNnz()) + (Math.min(hi_1_0_1.getNnz(), hi_1_1.getNnz()) * hi_1_1.getDim1() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0_1.getNnz() * (1.0 / hi_1_0_1.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_1.getDim1() * hi_1_1.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0_1.getNnz(), hi_1_1.getNnz()) * hi_1_1.getDim1() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0_1.getNnz() * (1.0 / hi_1_0_1.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_1.getDim1() * hi_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,%*%($1:*(b,C),D)) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0_1, hi_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,%*%($1:*(C,b),D)) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite571(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if (hi_1_0.getParent().size() > 1)
			return hi;
		if ( !(hi_1_0 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_0 = (BinaryOp) hi_1_0;

		if ( c_hi_1_0.getOp() != Types.OpOp2.MULT || !c_hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_0 = hi_1_0.getInput(0);

		if ( hi_1_0_0.getDataType() != Types.DataType.MATRIX || !hi_1_0_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_0_1 = hi_1_0.getInput(1);

		if ( hi_1_0_1.getDataType() != Types.DataType.SCALAR || !hi_1_0_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if ( hi_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0_0.getDim1() == -1 || hi_1_1.getDim2() == -1 || hi_1_0_0.getNnz() == -1 || hi_1_1.getDim1() == -1 || hi_0.getNnz() == -1 || hi_1_1.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_0_0.getNnz()) + (Math.min(hi_1_0_0.getNnz(), hi_1_1.getNnz()) * hi_1_1.getDim1() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0_0.getNnz() * (1.0 / hi_1_0_0.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_0.getDim1() * hi_1_1.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0_0.getNnz(), hi_1_1.getNnz()) * hi_1_1.getDim1() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0_0.getNnz() * (1.0 / hi_1_0_0.getDim1())), 1.0) * Math.min((hi_1_1.getNnz() * (1.0 / hi_1_1.getDim2())), 1.0) * hi_1_0_0.getDim1() * hi_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,%*%($1:*(C,b),D)) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0_0, hi_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_0_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_0);

		return v2;
	}

	// Implementation of the rule +(A,%*%(C,$1:*(b,D))) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite572(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.SCALAR || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.MATRIX || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_1_1_1.getNnz() == -1 || hi_1_0.getDim1() == -1 || hi_1_0.getDim2() == -1 || hi_1_1_1.getDim2() == -1 || hi_0.getNnz() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_1_1.getNnz()) + (Math.min(hi_1_0.getNnz(), hi_1_1_1.getNnz()) * hi_1_0.getDim2() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_1.getNnz() * (1.0 / hi_1_1_1.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_1.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0.getNnz(), hi_1_1_1.getNnz()) * hi_1_0.getDim2() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_1.getNnz() * (1.0 / hi_1_1_1.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_1.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,%*%(C,$1:*(b,D))) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_1_1_1);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_1_0, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}

	// Implementation of the rule +(A,%*%(C,$1:*(D,b))) => +*(A,b,%*%(C,D))
	private static Hop _applyRewrite573(Hop hi) {
		if ( !(hi instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi = (BinaryOp) hi;

		if ( c_hi.getOp() != Types.OpOp2.PLUS || !c_hi.getValueType().isNumeric() )
			return hi;

		Hop hi_0 = hi.getInput(0);

		if ( hi_0.getDataType() != Types.DataType.MATRIX || !hi_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1 = hi.getInput(1);

		if (hi_1.getParent().size() > 1)
			return hi;
		if ( !HopRewriteUtils.isMatrixMultiply(hi_1) )
			return hi;

		Hop hi_1_0 = hi_1.getInput(0);

		if ( hi_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1 = hi_1.getInput(1);

		if (hi_1_1.getParent().size() > 1)
			return hi;
		if ( !(hi_1_1 instanceof BinaryOp) )
			return hi;

		BinaryOp c_hi_1_1 = (BinaryOp) hi_1_1;

		if ( c_hi_1_1.getOp() != Types.OpOp2.MULT || !c_hi_1_1.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_0 = hi_1_1.getInput(0);

		if ( hi_1_1_0.getDataType() != Types.DataType.MATRIX || !hi_1_1_0.getValueType().isNumeric() )
			return hi;

		Hop hi_1_1_1 = hi_1_1.getInput(1);

		if ( hi_1_1_1.getDataType() != Types.DataType.SCALAR || !hi_1_1_1.getValueType().isNumeric() )
			return hi;


		if ( hi_1_0.getNnz() == -1 || hi_1_1_0.getDim1() == -1 || hi_1_0.getDim1() == -1 || hi_0.getNnz() == -1 || hi_1_1_0.getNnz() == -1 || hi_1_1_0.getDim2() == -1 )
			return hi;


		double costFrom = ((2.0 * hi_1_1_0.getNnz()) + (Math.min(hi_1_0.getNnz(), hi_1_1_0.getNnz()) * hi_1_1_0.getDim1() * 3.0) + (hi_0.getNnz() + (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_0.getNnz() * (1.0 / hi_1_1_0.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_0.getDim2())) + 30030.0);
		double costTo = ((Math.min(hi_1_0.getNnz(), hi_1_1_0.getNnz()) * hi_1_1_0.getDim1() * 3.0) + (3.0 * Math.min(hi_0.getNnz(), (Math.min((hi_1_0.getNnz() * (1.0 / hi_1_0.getDim1())), 1.0) * Math.min((hi_1_1_0.getNnz() * (1.0 / hi_1_1_0.getDim2())), 1.0) * hi_1_0.getDim1() * hi_1_1_0.getDim2()))) + 20070.0);

		if ( costFrom <= costTo )
			return hi;


		// Now, we start building the new Hop
		System.out.println("Applying rewrite: +(A,%*%(C,$1:*(D,b))) => +*(A,b,%*%(C,D))");
		AggBinaryOp v1 = HopRewriteUtils.createMatrixMultiply(hi_1_0, hi_1_1_0);
		TernaryOp v2 = HopRewriteUtils.createTernary(hi_0, hi_1_1_1, v1,Types.OpOp3.PLUS_MULT);

		ArrayList<Hop> parents = new ArrayList<>(hi.getParent());

		for ( Hop p : parents )
			HopRewriteUtils.replaceChildReference(p, hi, v2);

		// Remove old unreferenced Hops
		HopRewriteUtils.cleanupUnreferenced(hi);
		HopRewriteUtils.cleanupUnreferenced(hi_1);
		HopRewriteUtils.cleanupUnreferenced(hi_1_1);

		return v2;
	}
}