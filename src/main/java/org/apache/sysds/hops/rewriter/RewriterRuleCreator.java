package org.apache.sysds.hops.rewriter;

import java.util.HashMap;
import java.util.Map;

public class RewriterRuleCreator {
	public static RewriterRule createRule(RewriterStatement from, RewriterStatement to, RewriterStatement canonicalForm1, RewriterStatement canonicalForm2, final RuleContext ctx) {
		from = from.nestedCopy();
		to = to.nestedCopy();
		Map<RewriterStatement, RewriterStatement> assocs = getAssociations(from, to, canonicalForm1, canonicalForm2, ctx);

		// Now, we replace all variables with a common element
		from.forEachPreOrder((cur, parent, pIdx) -> {
			for (int i = 0; i < cur.getOperands().size(); i++) {
				RewriterStatement child = cur.getChild(i);

				if (child instanceof RewriterDataType && !child.isLiteral()) {
					RewriterStatement newRef = assocs.get(cur.getChild(i));

					if (newRef == null)
						throw new IllegalArgumentException();

					cur.getOperands().set(i, newRef);
				}
			}

			return true;
		});

		RewriterRule rule = new RewriterRuleBuilder(ctx, "Autogenerated rule").setUnidirectional(true).completeRule(from, to).build();
		return rule;
	}

	private static Map<RewriterStatement, RewriterStatement> getAssociations(RewriterStatement from, RewriterStatement to, RewriterStatement canonicalFormFrom, RewriterStatement canonicalFormTo, final RuleContext ctx) {
		Map<RewriterStatement, RewriterStatement> fromCanonicalLink = getAssociationToCanonicalForm(from, canonicalFormFrom, true);
		Map<RewriterStatement, RewriterStatement> toCanonicalLink = getAssociationToCanonicalForm(to, canonicalFormTo, true);

		RewriterStatement.MatcherContext matcher = RewriterStatement.MatcherContext.exactMatch(ctx, canonicalFormTo);
		canonicalFormFrom.match(matcher);

		Map<RewriterStatement, RewriterStatement> assocs = new HashMap<>();
		matcher.getDependencyMap().forEach((k, v) -> {
			if (k.isLiteral())
				return;

			RewriterStatement newKey = fromCanonicalLink.get(k);
			RewriterStatement newValue = toCanonicalLink.get(v);

			if (newKey == null || newValue == null)
				throw new IllegalArgumentException("Null reference detected!");

			assocs.put(newKey, newValue);
		});

		return assocs;
	}

	private static Map<RewriterStatement, RewriterStatement> getAssociationToCanonicalForm(RewriterStatement stmt, RewriterStatement canonicalForm, boolean reversed) {
		// We identify all associations by their names
		// If there are name collisions, this does not work
		Map<String, RewriterStatement> namedVariables = new HashMap<>();
		stmt.forEachPostOrder((cur, parent, pIdx) -> {
			if (!(cur instanceof RewriterDataType) || cur.isLiteral())
				return;

			if (namedVariables.put(cur.getId(), cur) != null)
				throw new IllegalArgumentException("Duplicate variable name: " + cur.toParsableString(RuleContext.currentContext));
		});

		Map<RewriterStatement, RewriterStatement> assoc = new HashMap<>();

		canonicalForm.forEachPostOrder((cur, parent, pIdx) -> {
			if (!(cur instanceof RewriterDataType) || cur.isLiteral())
				return;

			RewriterStatement ref = namedVariables.get(cur.getId());

			if (ref == null)
				throw new IllegalArgumentException("Unknown variable reference name '" + cur.getId() + "' in: " + cur.toParsableString(RuleContext.currentContext));

			if (reversed)
				assoc.put(cur, ref);
			else
				assoc.put(ref, cur);
		});

		return assoc;
	}
}
